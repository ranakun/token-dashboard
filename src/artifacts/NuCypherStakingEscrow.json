{
  "address": "0xD3D045370adF429C20C52EC16683E6637a2a7C09",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "staker",
          "type": "address"
        }
      ],
      "name": "getAllTokens",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "investigators",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "staker",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "stakingProvider",
          "type": "address"
        }
      ],
      "name": "requestMerge",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "staker",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "setStaker",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "staker",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "penalty",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "investigator",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "reward",
          "type": "uint256"
        }
      ],
      "name": "slashStaker",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "staker",
          "type": "address"
        }
      ],
      "name": "stakerInfo",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "stakingProvider",
              "type": "address"
            }
          ],
          "internalType": "struct NuCypherTokenStakingMock.StakerStruct",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "stakers",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "stakingProvider",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xfb4241f2ced23d95a3c6d46c52d443a20c7835f0cbd7e5b0e447652a3991b8f3",
  "receipt": {
    "to": null,
    "from": "0x018c56a5a8b93cB3Bc03005f229AE3D46cD3E7B5",
    "contractAddress": "0xD3D045370adF429C20C52EC16683E6637a2a7C09",
    "transactionIndex": 45,
    "gasUsed": "327718",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x367321635088fd7d188e251c2d7888827a109570938c65499597514801b6575b",
    "transactionHash": "0xfb4241f2ced23d95a3c6d46c52d443a20c7835f0cbd7e5b0e447652a3991b8f3",
    "logs": [],
    "blockNumber": 8529879,
    "cumulativeGasUsed": "15449647",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "22c1c09bba6d1078c29775cc67829122",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getAllTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"investigators\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stakingProvider\",\"type\":\"address\"}],\"name\":\"requestMerge\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setStaker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"investigator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"slashStaker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"stakerInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"stakingProvider\",\"type\":\"address\"}],\"internalType\":\"struct NuCypherTokenStakingMock.StakerStruct\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"stakingProvider\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"slashStaker(address,uint256,address,uint256)\":{\"params\":{\"investigator\":\"Investigator\",\"penalty\":\"Penalty\",\"reward\":\"Reward for the investigator\",\"staker\":\"Staker's address\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getAllTokens(address)\":{\"notice\":\"Get all tokens belonging to the staker\"},\"requestMerge(address,address)\":{\"notice\":\"Request merge between NuCypher staking contract and T staking contract.         Returns amount of staked tokens\"},\"slashStaker(address,uint256,address,uint256)\":{\"notice\":\"Slash the staker's stake and reward the investigator\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/test/TokenStakingTestSet.sol\":\"NuCypherTokenStakingMock\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x372b0bc04e3b4c074559bbbfb1317afddb56de5504158ca25a7f9cd403980445\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x6777f3fccb5dab95a9088ef62c41bee0198fd92e50d7c94f0e3733788af4079e\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3e26a49d2fa5ef8338b8a9467c91e54f417cb07e849b1cc0f4ebc4d2a147938e\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x55cf2bd9fc76704ddcdc19834cd288b7de00fc0f298a40ea16a954ae8991db2d\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary MathUpgradeable {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\",\"keccak256\":\"0xd0a917e32d1251a9b2f1dea15e932815d5382e64e6b0a18104664a6cc774cd70\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCastUpgradeable {\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= type(int128).min && value <= type(int128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= type(int64).min && value <= type(int64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= type(int32).min && value <= type(int32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= type(int16).min && value <= type(int16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= type(int8).min && value <= type(int8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0xcec885ecdf113b4265ed0856972d7ff167bfeb3802604b18cbb782bf47ecc4ae\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0x24e0364e503a9bbde94c715d26573a76f14cd2a202d45f96f52134ab806b67b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xbbc8ac883ac3c0078ce5ad3e288fbb3ffcc8a30c3a98c0fda0114d64fc44fca2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc3d946432c0ddbb1f846a0d3985be71299df331b91d06732152117f62f0be2b5\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x516a22876c1fab47f49b1bc22b4614491cd05338af8bd2e7b382da090a079990\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2ccf9d2313a313d41a791505f2b5abfdc62191b5d4334f7f7a82691c088a1c87\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= type(int128).min && value <= type(int128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= type(int64).min && value <= type(int64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= type(int32).min && value <= type(int32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= type(int16).min && value <= type(int16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= type(int8).min && value <= type(int8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x5c6caab697d302ad7eb59c234a4d2dbc965c1bae87709bd2850060b7695b28c7\",\"license\":\"MIT\"},\"@thesis/solidity-contracts/contracts/token/ERC20WithPermit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"./IERC20WithPermit.sol\\\";\\nimport \\\"./IReceiveApproval.sol\\\";\\n\\n/// @title  ERC20WithPermit\\n/// @notice Burnable ERC20 token with EIP2612 permit functionality. User can\\n///         authorize a transfer of their token with a signature conforming\\n///         EIP712 standard instead of an on-chain transaction from their\\n///         address. Anyone can submit this signature on the user's behalf by\\n///         calling the permit function, as specified in EIP2612 standard,\\n///         paying gas fees, and possibly performing other actions in the same\\n///         transaction.\\ncontract ERC20WithPermit is IERC20WithPermit, Ownable {\\n    /// @notice The amount of tokens owned by the given account.\\n    mapping(address => uint256) public override balanceOf;\\n\\n    /// @notice The remaining number of tokens that spender will be\\n    ///         allowed to spend on behalf of owner through `transferFrom` and\\n    ///         `burnFrom`. This is zero by default.\\n    mapping(address => mapping(address => uint256)) public override allowance;\\n\\n    /// @notice Returns the current nonce for EIP2612 permission for the\\n    ///         provided token owner for a replay protection. Used to construct\\n    ///         EIP2612 signature provided to `permit` function.\\n    mapping(address => uint256) public override nonce;\\n\\n    uint256 public immutable cachedChainId;\\n    bytes32 public immutable cachedDomainSeparator;\\n\\n    /// @notice Returns EIP2612 Permit message hash. Used to construct EIP2612\\n    ///         signature provided to `permit` function.\\n    bytes32 public constant override PERMIT_TYPEHASH =\\n        keccak256(\\n            \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n        );\\n\\n    /// @notice The amount of tokens in existence.\\n    uint256 public override totalSupply;\\n\\n    /// @notice The name of the token.\\n    string public override name;\\n\\n    /// @notice The symbol of the token.\\n    string public override symbol;\\n\\n    /// @notice The decimals places of the token.\\n    uint8 public constant override decimals = 18;\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n\\n        cachedChainId = block.chainid;\\n        cachedDomainSeparator = buildDomainSeparator();\\n    }\\n\\n    /// @notice Moves `amount` tokens from the caller's account to `recipient`.\\n    /// @return True if the operation succeeded, reverts otherwise.\\n    /// @dev Requirements:\\n    ///       - `recipient` cannot be the zero address,\\n    ///       - the caller must have a balance of at least `amount`.\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    /// @notice Moves `amount` tokens from `spender` to `recipient` using the\\n    ///         allowance mechanism. `amount` is then deducted from the caller's\\n    ///         allowance unless the allowance was made for `type(uint256).max`.\\n    /// @return True if the operation succeeded, reverts otherwise.\\n    /// @dev Requirements:\\n    ///      - `spender` and `recipient` cannot be the zero address,\\n    ///      - `spender` must have a balance of at least `amount`,\\n    ///      - the caller must have allowance for `spender`'s tokens of at least\\n    ///        `amount`.\\n    function transferFrom(\\n        address spender,\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        uint256 currentAllowance = allowance[spender][msg.sender];\\n        if (currentAllowance != type(uint256).max) {\\n            require(\\n                currentAllowance >= amount,\\n                \\\"Transfer amount exceeds allowance\\\"\\n            );\\n            _approve(spender, msg.sender, currentAllowance - amount);\\n        }\\n        _transfer(spender, recipient, amount);\\n        return true;\\n    }\\n\\n    /// @notice EIP2612 approval made with secp256k1 signature.\\n    ///         Users can authorize a transfer of their tokens with a signature\\n    ///         conforming EIP712 standard, rather than an on-chain transaction\\n    ///         from their address. Anyone can submit this signature on the\\n    ///         user's behalf by calling the permit function, paying gas fees,\\n    ///         and possibly performing other actions in the same transaction.\\n    /// @dev    The deadline argument can be set to `type(uint256).max to create\\n    ///         permits that effectively never expire.  If the `amount` is set\\n    ///         to `type(uint256).max` then `transferFrom` and `burnFrom` will\\n    ///         not reduce an allowance.\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override {\\n        /* solhint-disable-next-line not-rely-on-time */\\n        require(deadline >= block.timestamp, \\\"Permission expired\\\");\\n\\n        // Validate `s` and `v` values for a malleability concern described in EIP2.\\n        // Only signatures with `s` value in the lower half of the secp256k1\\n        // curve's order and `v` value of 27 or 28 are considered valid.\\n        require(\\n            uint256(s) <=\\n                0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\\n            \\\"Invalid signature 's' value\\\"\\n        );\\n        require(v == 27 || v == 28, \\\"Invalid signature 'v' value\\\");\\n\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR(),\\n                keccak256(\\n                    abi.encode(\\n                        PERMIT_TYPEHASH,\\n                        owner,\\n                        spender,\\n                        amount,\\n                        nonce[owner]++,\\n                        deadline\\n                    )\\n                )\\n            )\\n        );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(\\n            recoveredAddress != address(0) && recoveredAddress == owner,\\n            \\\"Invalid signature\\\"\\n        );\\n        _approve(owner, spender, amount);\\n    }\\n\\n    /// @notice Creates `amount` tokens and assigns them to `account`,\\n    ///         increasing the total supply.\\n    /// @dev Requirements:\\n    ///      - `recipient` cannot be the zero address.\\n    function mint(address recipient, uint256 amount) external onlyOwner {\\n        require(recipient != address(0), \\\"Mint to the zero address\\\");\\n\\n        beforeTokenTransfer(address(0), recipient, amount);\\n\\n        totalSupply += amount;\\n        balanceOf[recipient] += amount;\\n        emit Transfer(address(0), recipient, amount);\\n    }\\n\\n    /// @notice Destroys `amount` tokens from the caller.\\n    /// @dev Requirements:\\n    ///       - the caller must have a balance of at least `amount`.\\n    function burn(uint256 amount) external override {\\n        _burn(msg.sender, amount);\\n    }\\n\\n    /// @notice Destroys `amount` of tokens from `account` using the allowance\\n    ///         mechanism. `amount` is then deducted from the caller's allowance\\n    ///         unless the allowance was made for `type(uint256).max`.\\n    /// @dev Requirements:\\n    ///      - `account` must have a balance of at least `amount`,\\n    ///      - the caller must have allowance for `account`'s tokens of at least\\n    ///        `amount`.\\n    function burnFrom(address account, uint256 amount) external override {\\n        uint256 currentAllowance = allowance[account][msg.sender];\\n        if (currentAllowance != type(uint256).max) {\\n            require(\\n                currentAllowance >= amount,\\n                \\\"Burn amount exceeds allowance\\\"\\n            );\\n            _approve(account, msg.sender, currentAllowance - amount);\\n        }\\n        _burn(account, amount);\\n    }\\n\\n    /// @notice Calls `receiveApproval` function on spender previously approving\\n    ///         the spender to withdraw from the caller multiple times, up to\\n    ///         the `amount` amount. If this function is called again, it\\n    ///         overwrites the current allowance with `amount`. Reverts if the\\n    ///         approval reverted or if `receiveApproval` call on the spender\\n    ///         reverted.\\n    /// @return True if both approval and `receiveApproval` calls succeeded.\\n    /// @dev If the `amount` is set to `type(uint256).max` then\\n    ///      `transferFrom` and `burnFrom` will not reduce an allowance.\\n    function approveAndCall(\\n        address spender,\\n        uint256 amount,\\n        bytes memory extraData\\n    ) external override returns (bool) {\\n        if (approve(spender, amount)) {\\n            IReceiveApproval(spender).receiveApproval(\\n                msg.sender,\\n                amount,\\n                address(this),\\n                extraData\\n            );\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's\\n    ///         tokens.\\n    /// @return True if the operation succeeded.\\n    /// @dev If the `amount` is set to `type(uint256).max` then\\n    ///      `transferFrom` and `burnFrom` will not reduce an allowance.\\n    ///      Beware that changing an allowance with this method brings the risk\\n    ///      that someone may use both the old and the new allowance by\\n    ///      unfortunate transaction ordering. One possible solution to mitigate\\n    ///      this race condition is to first reduce the spender's allowance to 0\\n    ///      and set the desired value afterwards:\\n    ///      https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    function approve(address spender, uint256 amount)\\n        public\\n        override\\n        returns (bool)\\n    {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /// @notice Returns hash of EIP712 Domain struct with the token name as\\n    ///         a signing domain and token contract as a verifying contract.\\n    ///         Used to construct EIP2612 signature provided to `permit`\\n    ///         function.\\n    /* solhint-disable-next-line func-name-mixedcase */\\n    function DOMAIN_SEPARATOR() public view override returns (bytes32) {\\n        // As explained in EIP-2612, if the DOMAIN_SEPARATOR contains the\\n        // chainId and is defined at contract deployment instead of\\n        // reconstructed for every signature, there is a risk of possible replay\\n        // attacks between chains in the event of a future chain split.\\n        // To address this issue, we check the cached chain ID against the\\n        // current one and in case they are different, we build domain separator\\n        // from scratch.\\n        if (block.chainid == cachedChainId) {\\n            return cachedDomainSeparator;\\n        } else {\\n            return buildDomainSeparator();\\n        }\\n    }\\n\\n    /// @dev Hook that is called before any transfer of tokens. This includes\\n    ///      minting and burning.\\n    ///\\n    /// Calling conditions:\\n    /// - when `from` and `to` are both non-zero, `amount` of `from`'s tokens\\n    ///   will be to transferred to `to`.\\n    /// - when `from` is zero, `amount` tokens will be minted for `to`.\\n    /// - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n    /// - `from` and `to` are never both zero.\\n    // slither-disable-next-line dead-code\\n    function beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    function _burn(address account, uint256 amount) internal {\\n        uint256 currentBalance = balanceOf[account];\\n        require(currentBalance >= amount, \\\"Burn amount exceeds balance\\\");\\n\\n        beforeTokenTransfer(account, address(0), amount);\\n\\n        balanceOf[account] = currentBalance - amount;\\n        totalSupply -= amount;\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    function _transfer(\\n        address spender,\\n        address recipient,\\n        uint256 amount\\n    ) private {\\n        require(spender != address(0), \\\"Transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"Transfer to the zero address\\\");\\n        require(recipient != address(this), \\\"Transfer to the token address\\\");\\n\\n        beforeTokenTransfer(spender, recipient, amount);\\n\\n        uint256 spenderBalance = balanceOf[spender];\\n        require(spenderBalance >= amount, \\\"Transfer amount exceeds balance\\\");\\n        balanceOf[spender] = spenderBalance - amount;\\n        balanceOf[recipient] += amount;\\n        emit Transfer(spender, recipient, amount);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) private {\\n        require(owner != address(0), \\\"Approve from the zero address\\\");\\n        require(spender != address(0), \\\"Approve to the zero address\\\");\\n        allowance[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function buildDomainSeparator() private view returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\n                        \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n                    ),\\n                    keccak256(bytes(name)),\\n                    keccak256(bytes(\\\"1\\\")),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x1e1bf4ec5c9d6fe70f6f834316482aeff3f122ff4ffaa7178099e7ae71a0b16d\",\"license\":\"MIT\"},\"@thesis/solidity-contracts/contracts/token/IApproveAndCall.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\n/// @notice An interface that should be implemented by tokens supporting\\n///         `approveAndCall`/`receiveApproval` pattern.\\ninterface IApproveAndCall {\\n    /// @notice Executes `receiveApproval` function on spender as specified in\\n    ///         `IReceiveApproval` interface. Approves spender to withdraw from\\n    ///         the caller multiple times, up to the `amount`. If this\\n    ///         function is called again, it overwrites the current allowance\\n    ///         with `amount`. Reverts if the approval reverted or if\\n    ///         `receiveApproval` call on the spender reverted.\\n    function approveAndCall(\\n        address spender,\\n        uint256 amount,\\n        bytes memory extraData\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x393d18ef81a57dcc96fff4c340cc2945deaebb37b9796c322cf2bc96872c3df8\",\"license\":\"MIT\"},\"@thesis/solidity-contracts/contracts/token/IERC20WithPermit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\nimport \\\"./IApproveAndCall.sol\\\";\\n\\n/// @title  IERC20WithPermit\\n/// @notice Burnable ERC20 token with EIP2612 permit functionality. User can\\n///         authorize a transfer of their token with a signature conforming\\n///         EIP712 standard instead of an on-chain transaction from their\\n///         address. Anyone can submit this signature on the user's behalf by\\n///         calling the permit function, as specified in EIP2612 standard,\\n///         paying gas fees, and possibly performing other actions in the same\\n///         transaction.\\ninterface IERC20WithPermit is IERC20, IERC20Metadata, IApproveAndCall {\\n    /// @notice EIP2612 approval made with secp256k1 signature.\\n    ///         Users can authorize a transfer of their tokens with a signature\\n    ///         conforming EIP712 standard, rather than an on-chain transaction\\n    ///         from their address. Anyone can submit this signature on the\\n    ///         user's behalf by calling the permit function, paying gas fees,\\n    ///         and possibly performing other actions in the same transaction.\\n    /// @dev    The deadline argument can be set to `type(uint256).max to create\\n    ///         permits that effectively never expire.\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /// @notice Destroys `amount` tokens from the caller.\\n    function burn(uint256 amount) external;\\n\\n    /// @notice Destroys `amount` of tokens from `account`, deducting the amount\\n    ///         from caller's allowance.\\n    function burnFrom(address account, uint256 amount) external;\\n\\n    /// @notice Returns hash of EIP712 Domain struct with the token name as\\n    ///         a signing domain and token contract as a verifying contract.\\n    ///         Used to construct EIP2612 signature provided to `permit`\\n    ///         function.\\n    /* solhint-disable-next-line func-name-mixedcase */\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    /// @notice Returns the current nonce for EIP2612 permission for the\\n    ///         provided token owner for a replay protection. Used to construct\\n    ///         EIP2612 signature provided to `permit` function.\\n    function nonce(address owner) external view returns (uint256);\\n\\n    /// @notice Returns EIP2612 Permit message hash. Used to construct EIP2612\\n    ///         signature provided to `permit` function.\\n    /* solhint-disable-next-line func-name-mixedcase */\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n}\\n\",\"keccak256\":\"0xdac9a5086c19a7128b505a7be1ab0ac1aa314f6989cb88d2417e9d7383f89fa9\",\"license\":\"MIT\"},\"@thesis/solidity-contracts/contracts/token/IReceiveApproval.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\n/// @notice An interface that should be implemented by contracts supporting\\n///         `approveAndCall`/`receiveApproval` pattern.\\ninterface IReceiveApproval {\\n    /// @notice Receives approval to spend tokens. Called as a result of\\n    ///         `approveAndCall` call on the token.\\n    function receiveApproval(\\n        address from,\\n        uint256 amount,\\n        address token,\\n        bytes calldata extraData\\n    ) external;\\n}\\n\",\"keccak256\":\"0x6a30d83ad230548b1e7839737affc8489a035314209de14b89dbef7fb0f66395\",\"license\":\"MIT\"},\"@thesis/solidity-contracts/contracts/token/MisfundRecovery.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\n/// @title  MisfundRecovery\\n/// @notice Allows the owner of the token contract extending MisfundRecovery\\n///         to recover any ERC20 and ERC721 sent mistakenly to the token\\n///         contract address.\\ncontract MisfundRecovery is Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    function recoverERC20(\\n        IERC20 token,\\n        address recipient,\\n        uint256 amount\\n    ) external onlyOwner {\\n        token.safeTransfer(recipient, amount);\\n    }\\n\\n    function recoverERC721(\\n        IERC721 token,\\n        address recipient,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external onlyOwner {\\n        token.safeTransferFrom(address(this), recipient, tokenId, data);\\n    }\\n}\\n\",\"keccak256\":\"0xbbfea02bf20e2a6df5a497bbc05c7540a3b7c7dfb8b1feeaffef7f6b8ba65d65\",\"license\":\"MIT\"},\"contracts/governance/Checkpoints.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n\\r\\npragma solidity 0.8.9;\\r\\n\\r\\nimport \\\"./IVotesHistory.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\\\";\\r\\n\\r\\n/// @title Checkpoints\\r\\n/// @dev Abstract contract to support checkpoints for Compound-like voting and\\r\\n///      delegation. This implementation supports token supply up to 2^96 - 1.\\r\\n///      This contract keeps a history (checkpoints) of each account's vote\\r\\n///      power. Vote power can be delegated either by calling the {delegate}\\r\\n///      function directly, or by providing a signature to be used with\\r\\n///      {delegateBySig}. Voting power can be publicly queried through\\r\\n///      {getVotes} and {getPastVotes}.\\r\\n///      NOTE: Extracted from OpenZeppelin ERCVotes.sol.\\r\\n/// @dev This contract is upgrade-safe.\\r\\nabstract contract Checkpoints is IVotesHistory {\\r\\n    struct Checkpoint {\\r\\n        uint32 fromBlock;\\r\\n        uint96 votes;\\r\\n    }\\r\\n\\r\\n    // slither-disable-next-line uninitialized-state\\r\\n    mapping(address => address) internal _delegates;\\r\\n    mapping(address => uint128[]) internal _checkpoints;\\r\\n    uint128[] internal _totalSupplyCheckpoints;\\r\\n\\r\\n    // Reserved storage space in case we need to add more variables,\\r\\n    // since there are upgradeable contracts that inherit from this one.\\r\\n    // See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\r\\n    // slither-disable-next-line unused-state\\r\\n    uint256[47] private __gap;\\r\\n\\r\\n    /// @notice Emitted when an account changes their delegate.\\r\\n    event DelegateChanged(\\r\\n        address indexed delegator,\\r\\n        address indexed fromDelegate,\\r\\n        address indexed toDelegate\\r\\n    );\\r\\n\\r\\n    /// @notice Emitted when a balance or delegate change results in changes\\r\\n    ///         to an account's voting power.\\r\\n    event DelegateVotesChanged(\\r\\n        address indexed delegate,\\r\\n        uint256 previousBalance,\\r\\n        uint256 newBalance\\r\\n    );\\r\\n\\r\\n    function checkpoints(address account, uint32 pos)\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        returns (Checkpoint memory checkpoint)\\r\\n    {\\r\\n        (uint32 fromBlock, uint96 votes) = decodeCheckpoint(\\r\\n            _checkpoints[account][pos]\\r\\n        );\\r\\n        checkpoint = Checkpoint(fromBlock, votes);\\r\\n    }\\r\\n\\r\\n    /// @notice Get number of checkpoints for `account`.\\r\\n    function numCheckpoints(address account)\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        returns (uint32)\\r\\n    {\\r\\n        return SafeCastUpgradeable.toUint32(_checkpoints[account].length);\\r\\n    }\\r\\n\\r\\n    /// @notice Get the address `account` is currently delegating to.\\r\\n    function delegates(address account) public view virtual returns (address) {\\r\\n        return _delegates[account];\\r\\n    }\\r\\n\\r\\n    /// @notice Gets the current votes balance for `account`.\\r\\n    /// @param account The address to get votes balance\\r\\n    /// @return The number of current votes for `account`\\r\\n    function getVotes(address account) public view returns (uint96) {\\r\\n        uint256 pos = _checkpoints[account].length;\\r\\n        return pos == 0 ? 0 : decodeValue(_checkpoints[account][pos - 1]);\\r\\n    }\\r\\n\\r\\n    /// @notice Determine the prior number of votes for an account as of\\r\\n    ///         a block number.\\r\\n    /// @dev Block number must be a finalized block or else this function will\\r\\n    ///      revert to prevent misinformation.\\r\\n    /// @param account The address of the account to check\\r\\n    /// @param blockNumber The block number to get the vote balance at\\r\\n    /// @return The number of votes the account had as of the given block\\r\\n    function getPastVotes(address account, uint256 blockNumber)\\r\\n        public\\r\\n        view\\r\\n        returns (uint96)\\r\\n    {\\r\\n        return lookupCheckpoint(_checkpoints[account], blockNumber);\\r\\n    }\\r\\n\\r\\n    /// @notice Retrieve the `totalSupply` at the end of `blockNumber`.\\r\\n    ///         Note, this value is the sum of all balances, but it is NOT the\\r\\n    ///         sum of all the delegated votes!\\r\\n    /// @param blockNumber The block number to get the total supply at\\r\\n    /// @dev `blockNumber` must have been already mined\\r\\n    function getPastTotalSupply(uint256 blockNumber)\\r\\n        public\\r\\n        view\\r\\n        returns (uint96)\\r\\n    {\\r\\n        return lookupCheckpoint(_totalSupplyCheckpoints, blockNumber);\\r\\n    }\\r\\n\\r\\n    /// @notice Change delegation for `delegator` to `delegatee`.\\r\\n    // slither-disable-next-line dead-code\\r\\n    function delegate(address delegator, address delegatee) internal virtual;\\r\\n\\r\\n    /// @notice Moves voting power from one delegate to another\\r\\n    /// @param src Address of old delegate\\r\\n    /// @param dst Address of new delegate\\r\\n    /// @param amount Voting power amount to transfer between delegates\\r\\n    function moveVotingPower(\\r\\n        address src,\\r\\n        address dst,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        if (src != dst && amount > 0) {\\r\\n            if (src != address(0)) {\\r\\n                // https://github.com/crytic/slither/issues/960\\r\\n                // slither-disable-next-line variable-scope\\r\\n                (uint256 oldWeight, uint256 newWeight) = writeCheckpoint(\\r\\n                    _checkpoints[src],\\r\\n                    subtract,\\r\\n                    amount\\r\\n                );\\r\\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\\r\\n            }\\r\\n\\r\\n            if (dst != address(0)) {\\r\\n                // https://github.com/crytic/slither/issues/959\\r\\n                // slither-disable-next-line uninitialized-local\\r\\n                (uint256 oldWeight, uint256 newWeight) = writeCheckpoint(\\r\\n                    _checkpoints[dst],\\r\\n                    add,\\r\\n                    amount\\r\\n                );\\r\\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Writes a new checkpoint based on operating last stored value\\r\\n    ///         with a `delta`. Usually, said operation is the `add` or\\r\\n    ///         `subtract` functions from this contract, but more complex\\r\\n    ///         functions can be passed as parameters.\\r\\n    /// @param ckpts The checkpoints array to use\\r\\n    /// @param op The function to apply over the last value and the `delta`\\r\\n    /// @param delta Variation with respect to last stored value to be used\\r\\n    ///              for new checkpoint\\r\\n    function writeCheckpoint(\\r\\n        uint128[] storage ckpts,\\r\\n        function(uint256, uint256) view returns (uint256) op,\\r\\n        uint256 delta\\r\\n    ) internal returns (uint256 oldWeight, uint256 newWeight) {\\r\\n        uint256 pos = ckpts.length;\\r\\n        oldWeight = pos == 0 ? 0 : decodeValue(ckpts[pos - 1]);\\r\\n        newWeight = op(oldWeight, delta);\\r\\n\\r\\n        if (pos > 0) {\\r\\n            uint32 fromBlock = decodeBlockNumber(ckpts[pos - 1]);\\r\\n            // slither-disable-next-line incorrect-equality\\r\\n            if (fromBlock == block.number) {\\r\\n                ckpts[pos - 1] = encodeCheckpoint(\\r\\n                    fromBlock,\\r\\n                    SafeCastUpgradeable.toUint96(newWeight)\\r\\n                );\\r\\n                return (oldWeight, newWeight);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        ckpts.push(\\r\\n            encodeCheckpoint(\\r\\n                SafeCastUpgradeable.toUint32(block.number),\\r\\n                SafeCastUpgradeable.toUint96(newWeight)\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Lookup a value in a list of (sorted) checkpoints.\\r\\n    /// @param ckpts The checkpoints array to use\\r\\n    /// @param blockNumber Block number when we want to get the checkpoint at\\r\\n    function lookupCheckpoint(uint128[] storage ckpts, uint256 blockNumber)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint96)\\r\\n    {\\r\\n        // We run a binary search to look for the earliest checkpoint taken\\r\\n        // after `blockNumber`. During the loop, the index of the wanted\\r\\n        // checkpoint remains in the range [low-1, high). With each iteration,\\r\\n        // either `low` or `high` is moved towards the middle of the range to\\r\\n        // maintain the invariant.\\r\\n        // - If the middle checkpoint is after `blockNumber`,\\r\\n        //   we look in [low, mid)\\r\\n        // - If the middle checkpoint is before or equal to `blockNumber`,\\r\\n        //   we look in [mid+1, high)\\r\\n        // Once we reach a single value (when low == high), we've found the\\r\\n        // right checkpoint at the index high-1, if not out of bounds (in that\\r\\n        // case we're looking too far in the past and the result is 0).\\r\\n        // Note that if the latest checkpoint available is exactly for\\r\\n        // `blockNumber`, we end up with an index that is past the end of the\\r\\n        // array, so we technically don't find a checkpoint after\\r\\n        // `blockNumber`, but it works out the same.\\r\\n        require(blockNumber < block.number, \\\"Block not yet determined\\\");\\r\\n\\r\\n        uint256 high = ckpts.length;\\r\\n        uint256 low = 0;\\r\\n        while (low < high) {\\r\\n            uint256 mid = MathUpgradeable.average(low, high);\\r\\n            uint32 midBlock = decodeBlockNumber(ckpts[mid]);\\r\\n            if (midBlock > blockNumber) {\\r\\n                high = mid;\\r\\n            } else {\\r\\n                low = mid + 1;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return high == 0 ? 0 : decodeValue(ckpts[high - 1]);\\r\\n    }\\r\\n\\r\\n    /// @notice Maximum token supply. Defaults to `type(uint96).max` (2^96 - 1)\\r\\n    // slither-disable-next-line dead-code\\r\\n    function maxSupply() internal view virtual returns (uint96) {\\r\\n        return type(uint96).max;\\r\\n    }\\r\\n\\r\\n    /// @notice Encodes a `blockNumber` and `value` into a single `uint128`\\r\\n    ///         checkpoint.\\r\\n    /// @dev `blockNumber` is stored in the first 32 bits, while `value` in the\\r\\n    ///      remaining 96 bits.\\r\\n    function encodeCheckpoint(uint32 blockNumber, uint96 value)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint128)\\r\\n    {\\r\\n        return (uint128(blockNumber) << 96) | uint128(value);\\r\\n    }\\r\\n\\r\\n    /// @notice Decodes a block number from a `uint128` `checkpoint`.\\r\\n    function decodeBlockNumber(uint128 checkpoint)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint32)\\r\\n    {\\r\\n        return uint32(bytes4(bytes16(checkpoint)));\\r\\n    }\\r\\n\\r\\n    /// @notice Decodes a voting value from a `uint128` `checkpoint`.\\r\\n    function decodeValue(uint128 checkpoint) internal pure returns (uint96) {\\r\\n        return uint96(checkpoint);\\r\\n    }\\r\\n\\r\\n    /// @notice Decodes a block number and voting value from a `uint128`\\r\\n    ///         `checkpoint`.\\r\\n    function decodeCheckpoint(uint128 checkpoint)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint32 blockNumber, uint96 value)\\r\\n    {\\r\\n        blockNumber = decodeBlockNumber(checkpoint);\\r\\n        value = decodeValue(checkpoint);\\r\\n    }\\r\\n\\r\\n    // slither-disable-next-line dead-code\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a + b;\\r\\n    }\\r\\n\\r\\n    // slither-disable-next-line dead-code\\r\\n    function subtract(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a - b;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xd090360d343ef0eb46d38f31820479d74173aa04353e639f1c6bdd9bfefa149d\",\"license\":\"GPL-3.0-or-later\"},\"contracts/governance/IVotesHistory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n\\r\\npragma solidity 0.8.9;\\r\\n\\r\\ninterface IVotesHistory {\\r\\n    function getPastVotes(address account, uint256 blockNumber)\\r\\n        external\\r\\n        view\\r\\n        returns (uint96);\\r\\n\\r\\n    function getPastTotalSupply(uint256 blockNumber)\\r\\n        external\\r\\n        view\\r\\n        returns (uint96);\\r\\n}\\r\\n\",\"keccak256\":\"0x98d9924c9a95d7107fedc4a74e5cdf19b3c9f55ad3805a69e39bae8857b115cd\",\"license\":\"GPL-3.0-or-later\"},\"contracts/staking/IApplication.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\n/// @title  Application interface for Threshold Network applications\\r\\n/// @notice Generic interface for an application. Application is an external\\r\\n///         smart contract or a set of smart contracts utilizing functionalities\\r\\n///         offered by Threshold Network. Applications authorized for the given\\r\\n///         staking provider are eligible to slash the stake delegated to that\\r\\n///         staking provider.\\r\\ninterface IApplication {\\r\\n    /// @dev Event emitted by `withdrawRewards` function.\\r\\n    event RewardsWithdrawn(address indexed stakingProvider, uint96 amount);\\r\\n\\r\\n    /// @notice Withdraws application rewards for the given staking provider.\\r\\n    ///         Rewards are withdrawn to the staking provider's beneficiary\\r\\n    ///         address set in the staking contract.\\r\\n    /// @dev Emits `RewardsWithdrawn` event.\\r\\n    function withdrawRewards(address stakingProvider) external;\\r\\n\\r\\n    /// @notice Used by T staking contract to inform the application that the\\r\\n    ///         authorized amount for the given staking provider increased.\\r\\n    ///         The application may do any necessary housekeeping. The\\r\\n    ///         application must revert the transaction in case the\\r\\n    ///         authorization is below the minimum required.\\r\\n    function authorizationIncreased(\\r\\n        address stakingProvider,\\r\\n        uint96 fromAmount,\\r\\n        uint96 toAmount\\r\\n    ) external;\\r\\n\\r\\n    /// @notice Used by T staking contract to inform the application that the\\r\\n    ///         authorization decrease for the given staking provider has been\\r\\n    ///         requested. The application should mark the authorization as\\r\\n    ///         pending decrease and respond to the staking contract with\\r\\n    ///         `approveAuthorizationDecrease` at its discretion. It may\\r\\n    ///         happen right away but it also may happen several months later.\\r\\n    ///         If there is already a pending authorization decrease request\\r\\n    ///         for the application, and the application does not agree for\\r\\n    ///         overwriting it, the function should revert.\\r\\n    function authorizationDecreaseRequested(\\r\\n        address stakingProvider,\\r\\n        uint96 fromAmount,\\r\\n        uint96 toAmount\\r\\n    ) external;\\r\\n\\r\\n    /// @notice Used by T staking contract to inform the application the\\r\\n    ///         authorization has been decreased for the given staking provider\\r\\n    ///         involuntarily, as a result of slashing. Lets the application to\\r\\n    ///         do any housekeeping neccessary. Called with 250k gas limit and\\r\\n    ///         does not revert the transaction if\\r\\n    ///         `involuntaryAuthorizationDecrease` call failed.\\r\\n    function involuntaryAuthorizationDecrease(\\r\\n        address stakingProvider,\\r\\n        uint96 fromAmount,\\r\\n        uint96 toAmount\\r\\n    ) external;\\r\\n\\r\\n    /// @notice Returns the amount of application rewards available for\\r\\n    ///         withdrawal for the given staking provider.\\r\\n    function availableRewards(address stakingProvider)\\r\\n        external\\r\\n        view\\r\\n        returns (uint96);\\r\\n\\r\\n    /// @notice The minimum authorization amount required for the staking\\r\\n    ///         provider so that they can participate in the application.\\r\\n    function minimumAuthorization() external view returns (uint96);\\r\\n}\\r\\n\",\"keccak256\":\"0xe70ae549d2c1d38712a050a6198e9bcfaf61f9e6dbeb2fc69bc931e6e7254771\",\"license\":\"GPL-3.0-or-later\"},\"contracts/staking/ILegacyTokenStaking.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n\\r\\npragma solidity 0.8.9;\\r\\n\\r\\n/// @title IKeepTokenStaking\\r\\n/// @notice Interface for Keep TokenStaking contract\\r\\ninterface IKeepTokenStaking {\\r\\n    /// @notice Seize provided token amount from every member in the misbehaved\\r\\n    /// operators array. The tattletale is rewarded with 5% of the total seized\\r\\n    /// amount scaled by the reward adjustment parameter and the rest 95% is burned.\\r\\n    /// @param amountToSeize Token amount to seize from every misbehaved operator.\\r\\n    /// @param rewardMultiplier Reward adjustment in percentage. Min 1% and 100% max.\\r\\n    /// @param tattletale Address to receive the 5% reward.\\r\\n    /// @param misbehavedOperators Array of addresses to seize the tokens from.\\r\\n    function seize(\\r\\n        uint256 amountToSeize,\\r\\n        uint256 rewardMultiplier,\\r\\n        address tattletale,\\r\\n        address[] memory misbehavedOperators\\r\\n    ) external;\\r\\n\\r\\n    /// @notice Gets stake delegation info for the given operator.\\r\\n    /// @param operator Operator address.\\r\\n    /// @return amount The amount of tokens the given operator delegated.\\r\\n    /// @return createdAt The time when the stake has been delegated.\\r\\n    /// @return undelegatedAt The time when undelegation has been requested.\\r\\n    /// If undelegation has not been requested, 0 is returned.\\r\\n    function getDelegationInfo(address operator)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 amount,\\r\\n            uint256 createdAt,\\r\\n            uint256 undelegatedAt\\r\\n        );\\r\\n\\r\\n    /// @notice Gets the stake owner for the specified operator address.\\r\\n    /// @return Stake owner address.\\r\\n    function ownerOf(address operator) external view returns (address);\\r\\n\\r\\n    /// @notice Gets the beneficiary for the specified operator address.\\r\\n    /// @return Beneficiary address.\\r\\n    function beneficiaryOf(address operator)\\r\\n        external\\r\\n        view\\r\\n        returns (address payable);\\r\\n\\r\\n    /// @notice Gets the authorizer for the specified operator address.\\r\\n    /// @return Authorizer address.\\r\\n    function authorizerOf(address operator) external view returns (address);\\r\\n\\r\\n    /// @notice Gets the eligible stake balance of the specified address.\\r\\n    /// An eligible stake is a stake that passed the initialization period\\r\\n    /// and is not currently undelegating. Also, the operator had to approve\\r\\n    /// the specified operator contract.\\r\\n    ///\\r\\n    /// Operator with a minimum required amount of eligible stake can join the\\r\\n    /// network and participate in new work selection.\\r\\n    ///\\r\\n    /// @param operator address of stake operator.\\r\\n    /// @param operatorContract address of operator contract.\\r\\n    /// @return balance an uint256 representing the eligible stake balance.\\r\\n    function eligibleStake(address operator, address operatorContract)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 balance);\\r\\n}\\r\\n\\r\\n/// @title INuCypherStakingEscrow\\r\\n/// @notice Interface for NuCypher StakingEscrow contract\\r\\ninterface INuCypherStakingEscrow {\\r\\n    /// @notice Slash the staker's stake and reward the investigator\\r\\n    /// @param staker Staker's address\\r\\n    /// @param penalty Penalty\\r\\n    /// @param investigator Investigator\\r\\n    /// @param reward Reward for the investigator\\r\\n    function slashStaker(\\r\\n        address staker,\\r\\n        uint256 penalty,\\r\\n        address investigator,\\r\\n        uint256 reward\\r\\n    ) external;\\r\\n\\r\\n    /// @notice Request merge between NuCypher staking contract and T staking contract.\\r\\n    ///         Returns amount of staked tokens\\r\\n    function requestMerge(address staker, address stakingProvider)\\r\\n        external\\r\\n        returns (uint256);\\r\\n\\r\\n    /// @notice Get all tokens belonging to the staker\\r\\n    function getAllTokens(address staker) external view returns (uint256);\\r\\n}\\r\\n\",\"keccak256\":\"0x194a4ea8c7340d9c84f98e0a9bc297867d20d7c0e74329faced9ee01a96361f8\",\"license\":\"GPL-3.0-or-later\"},\"contracts/staking/IStaking.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\n/// @title Interface of Threshold Network staking contract\\r\\n/// @notice The staking contract enables T owners to have their wallets offline\\r\\n///         and their stake managed by staking providers on their behalf.\\r\\n///         The staking contract does not define operator role. The operator\\r\\n///         responsible for running off-chain client software is appointed by\\r\\n///         the staking provider in the particular application utilizing the\\r\\n///         staking contract. All off-chain client software should be able\\r\\n///         to run without exposing operator's or staking provider\\u2019s private\\r\\n///         key and should not require any owner\\u2019s keys at all. The stake\\r\\n///         delegation optimizes the network throughput without compromising the\\r\\n///         security of the owners\\u2019 stake.\\r\\ninterface IStaking {\\r\\n    enum StakeType {\\r\\n        NU,\\r\\n        KEEP,\\r\\n        T\\r\\n    }\\r\\n\\r\\n    //\\r\\n    //\\r\\n    // Delegating a stake\\r\\n    //\\r\\n    //\\r\\n\\r\\n    /// @notice Creates a delegation with `msg.sender` owner with the given\\r\\n    ///         staking provider, beneficiary, and authorizer. Transfers the\\r\\n    ///         given amount of T to the staking contract.\\r\\n    /// @dev The owner of the delegation needs to have the amount approved to\\r\\n    ///      transfer to the staking contract.\\r\\n    function stake(\\r\\n        address stakingProvider,\\r\\n        address payable beneficiary,\\r\\n        address authorizer,\\r\\n        uint96 amount\\r\\n    ) external;\\r\\n\\r\\n    /// @notice Copies delegation from the legacy KEEP staking contract to T\\r\\n    ///         staking contract. No tokens are transferred. Caches the active\\r\\n    ///         stake amount from KEEP staking contract. Can be called by\\r\\n    ///         anyone.\\r\\n    /// @dev The staking provider in T staking contract is the legacy KEEP\\r\\n    ///      staking contract operator.\\r\\n    function stakeKeep(address stakingProvider) external;\\r\\n\\r\\n    /// @notice Copies delegation from the legacy NU staking contract to T\\r\\n    ///         staking contract, additionally appointing staking provider,\\r\\n    ///         beneficiary and authorizer roles. Caches the amount staked in NU\\r\\n    ///         staking contract. Can be called only by the original delegation\\r\\n    ///         owner.\\r\\n    function stakeNu(\\r\\n        address stakingProvider,\\r\\n        address payable beneficiary,\\r\\n        address authorizer\\r\\n    ) external;\\r\\n\\r\\n    /// @notice Refresh Keep stake owner. Can be called only by the old owner\\r\\n    ///         or their staking provider.\\r\\n    /// @dev The staking provider in T staking contract is the legacy KEEP\\r\\n    ///      staking contract operator.\\r\\n    function refreshKeepStakeOwner(address stakingProvider) external;\\r\\n\\r\\n    /// @notice Allows the Governance to set the minimum required stake amount.\\r\\n    ///         This amount is required to protect against griefing the staking\\r\\n    ///         contract and individual applications are allowed to require\\r\\n    ///         higher minimum stakes if necessary.\\r\\n    function setMinimumStakeAmount(uint96 amount) external;\\r\\n\\r\\n    //\\r\\n    //\\r\\n    // Authorizing an application\\r\\n    //\\r\\n    //\\r\\n\\r\\n    /// @notice Allows the Governance to approve the particular application\\r\\n    ///         before individual stake authorizers are able to authorize it.\\r\\n    function approveApplication(address application) external;\\r\\n\\r\\n    /// @notice Increases the authorization of the given staking provider for\\r\\n    ///         the given application by the given amount. Can only be called by\\r\\n    ///         the authorizer for that staking provider.\\r\\n    /// @dev Calls `authorizationIncreased(address stakingProvider, uint256 amount)`\\r\\n    ///      on the given application to notify the application about\\r\\n    ///      authorization change. See `IApplication`.\\r\\n    function increaseAuthorization(\\r\\n        address stakingProvider,\\r\\n        address application,\\r\\n        uint96 amount\\r\\n    ) external;\\r\\n\\r\\n    /// @notice Requests decrease of the authorization for the given staking\\r\\n    ///         provider on the given application by the provided amount.\\r\\n    ///         It may not change the authorized amount immediatelly. When\\r\\n    ///         it happens depends on the application. Can only be called by the\\r\\n    ///         given staking provider\\u2019s authorizer. Overwrites pending\\r\\n    ///         authorization decrease for the given staking provider and\\r\\n    ///         application if the application agrees for that. If the\\r\\n    ///         application does not agree for overwriting, the function\\r\\n    ///         reverts.\\r\\n    /// @dev Calls `authorizationDecreaseRequested(address stakingProvider, uint256 amount)`\\r\\n    ///      on the given application. See `IApplication`.\\r\\n    function requestAuthorizationDecrease(\\r\\n        address stakingProvider,\\r\\n        address application,\\r\\n        uint96 amount\\r\\n    ) external;\\r\\n\\r\\n    /// @notice Requests decrease of all authorizations for the given staking\\r\\n    ///         provider on all applications by all authorized amount.\\r\\n    ///         It may not change the authorized amount immediatelly. When\\r\\n    ///         it happens depends on the application. Can only be called by the\\r\\n    ///         given staking provider\\u2019s authorizer. Overwrites pending\\r\\n    ///         authorization decrease for the given staking provider and\\r\\n    ///         application.\\r\\n    /// @dev Calls `authorizationDecreaseRequested(address stakingProvider, uint256 amount)`\\r\\n    ///      for each authorized application. See `IApplication`.\\r\\n    function requestAuthorizationDecrease(address stakingProvider) external;\\r\\n\\r\\n    /// @notice Called by the application at its discretion to approve the\\r\\n    ///         previously requested authorization decrease request. Can only be\\r\\n    ///         called by the application that was previously requested to\\r\\n    ///         decrease the authorization for that staking provider.\\r\\n    ///         Returns resulting authorized amount for the application.\\r\\n    function approveAuthorizationDecrease(address stakingProvider)\\r\\n        external\\r\\n        returns (uint96);\\r\\n\\r\\n    /// @notice Decreases the authorization for the given `stakingProvider` on\\r\\n    ///         the given disabled `application`, for all authorized amount.\\r\\n    ///         Can be called by anyone.\\r\\n    function forceDecreaseAuthorization(\\r\\n        address stakingProvider,\\r\\n        address application\\r\\n    ) external;\\r\\n\\r\\n    /// @notice Pauses the given application\\u2019s eligibility to slash stakes.\\r\\n    ///         Besides that stakers can't change authorization to the application.\\r\\n    ///         Can be called only by the Panic Button of the particular\\r\\n    ///         application. The paused application can not slash stakes until\\r\\n    ///         it is approved again by the Governance using `approveApplication`\\r\\n    ///         function. Should be used only in case of an emergency.\\r\\n    function pauseApplication(address application) external;\\r\\n\\r\\n    /// @notice Disables the given application. The disabled application can't\\r\\n    ///         slash stakers. Also stakers can't increase authorization to that\\r\\n    ///         application but can decrease without waiting by calling\\r\\n    ///         `requestAuthorizationDecrease` at any moment. Can be called only\\r\\n    ///         by the governance. The disabled application can't be approved\\r\\n    ///         again. Should be used only in case of an emergency.\\r\\n    function disableApplication(address application) external;\\r\\n\\r\\n    /// @notice Sets the Panic Button role for the given application to the\\r\\n    ///         provided address. Can only be called by the Governance. If the\\r\\n    ///         Panic Button for the given application should be disabled, the\\r\\n    ///         role address should be set to 0x0 address.\\r\\n    function setPanicButton(address application, address panicButton) external;\\r\\n\\r\\n    /// @notice Sets the maximum number of applications one staking provider can\\r\\n    ///         have authorized. Used to protect against DoSing slashing queue.\\r\\n    ///         Can only be called by the Governance.\\r\\n    function setAuthorizationCeiling(uint256 ceiling) external;\\r\\n\\r\\n    //\\r\\n    //\\r\\n    // Stake top-up\\r\\n    //\\r\\n    //\\r\\n\\r\\n    /// @notice Increases the amount of the stake for the given staking provider.\\r\\n    /// @dev The sender of this transaction needs to have the amount approved to\\r\\n    ///      transfer to the staking contract.\\r\\n    function topUp(address stakingProvider, uint96 amount) external;\\r\\n\\r\\n    /// @notice Propagates information about stake top-up from the legacy KEEP\\r\\n    ///         staking contract to T staking contract. Can be called only by\\r\\n    ///         the owner or the staking provider.\\r\\n    function topUpKeep(address stakingProvider) external;\\r\\n\\r\\n    /// @notice Propagates information about stake top-up from the legacy NU\\r\\n    ///         staking contract to T staking contract. Can be called only by\\r\\n    ///         the owner or the staking provider.\\r\\n    function topUpNu(address stakingProvider) external;\\r\\n\\r\\n    //\\r\\n    //\\r\\n    // Undelegating a stake (unstaking)\\r\\n    //\\r\\n    //\\r\\n\\r\\n    /// @notice Reduces the liquid T stake amount by the provided amount and\\r\\n    ///         withdraws T to the owner. Reverts if there is at least one\\r\\n    ///         authorization higher than the sum of the legacy stake and\\r\\n    ///         remaining liquid T stake or if the unstake amount is higher than\\r\\n    ///         the liquid T stake amount. Can be called only by the delegation\\r\\n    ///         owner or the staking provider.\\r\\n    function unstakeT(address stakingProvider, uint96 amount) external;\\r\\n\\r\\n    /// @notice Sets the legacy KEEP staking contract active stake amount cached\\r\\n    ///         in T staking contract to 0. Reverts if the amount of liquid T\\r\\n    ///         staked in T staking contract is lower than the highest\\r\\n    ///         application authorization. This function allows to unstake from\\r\\n    ///         KEEP staking contract and still being able to operate in T\\r\\n    ///         network and earning rewards based on the liquid T staked. Can be\\r\\n    ///         called only by the delegation owner or the staking provider.\\r\\n    function unstakeKeep(address stakingProvider) external;\\r\\n\\r\\n    /// @notice Reduces cached legacy NU stake amount by the provided amount.\\r\\n    ///         Reverts if there is at least one authorization higher than the\\r\\n    ///         sum of remaining legacy NU stake and liquid T stake for that\\r\\n    ///         staking provider or if the untaked amount is higher than the\\r\\n    ///         cached legacy stake amount. If succeeded, the legacy NU stake\\r\\n    ///         can be partially or fully undelegated on the legacy staking\\r\\n    ///         contract. This function allows to unstake from NU staking\\r\\n    ///         contract and still being able to operate in T network and\\r\\n    ///         earning rewards based on the liquid T staked. Can be called only\\r\\n    ///         by the delegation owner or the staking provider.\\r\\n    function unstakeNu(address stakingProvider, uint96 amount) external;\\r\\n\\r\\n    /// @notice Sets cached legacy stake amount to 0, sets the liquid T stake\\r\\n    ///         amount to 0 and withdraws all liquid T from the stake to the\\r\\n    ///         owner. Reverts if there is at least one non-zero authorization.\\r\\n    ///         Can be called only by the delegation owner or the staking\\r\\n    ///         provider.\\r\\n    function unstakeAll(address stakingProvider) external;\\r\\n\\r\\n    //\\r\\n    //\\r\\n    // Keeping information in sync\\r\\n    //\\r\\n    //\\r\\n\\r\\n    /// @notice Notifies about the discrepancy between legacy KEEP active stake\\r\\n    ///         and the amount cached in T staking contract. Slashes the staking\\r\\n    ///         provider in case the amount cached is higher than the actual\\r\\n    ///         active stake amount in KEEP staking contract. Needs to update\\r\\n    ///         authorizations of all affected applications and execute an\\r\\n    ///         involuntary allocation decrease on all affected applications.\\r\\n    ///         Can be called by anyone, notifier receives a reward.\\r\\n    function notifyKeepStakeDiscrepancy(address stakingProvider) external;\\r\\n\\r\\n    /// @notice Notifies about the discrepancy between legacy NU active stake\\r\\n    ///         and the amount cached in T staking contract. Slashes the\\r\\n    ///         staking provider in case the amount cached is higher than the\\r\\n    ///         actual active stake amount in NU staking contract. Needs to\\r\\n    ///         update authorizations of all affected applications and execute\\r\\n    ///         an involuntary allocation decrease on all affected applications.\\r\\n    ///         Can be called by anyone, notifier receives a reward.\\r\\n    function notifyNuStakeDiscrepancy(address stakingProvider) external;\\r\\n\\r\\n    /// @notice Sets the penalty amount for stake discrepancy and reward\\r\\n    ///         multiplier for reporting it. The penalty is seized from the\\r\\n    ///         delegated stake, and 5% of the penalty, scaled by the\\r\\n    ///         multiplier, is given to the notifier. The rest of the tokens are\\r\\n    ///         burned. Can only be called by the Governance. See `seize` function.\\r\\n    function setStakeDiscrepancyPenalty(\\r\\n        uint96 penalty,\\r\\n        uint256 rewardMultiplier\\r\\n    ) external;\\r\\n\\r\\n    /// @notice Sets reward in T tokens for notification of misbehaviour\\r\\n    ///         of one staking provider. Can only be called by the governance.\\r\\n    function setNotificationReward(uint96 reward) external;\\r\\n\\r\\n    /// @notice Transfer some amount of T tokens as reward for notifications\\r\\n    ///         of misbehaviour\\r\\n    function pushNotificationReward(uint96 reward) external;\\r\\n\\r\\n    /// @notice Withdraw some amount of T tokens from notifiers treasury.\\r\\n    ///         Can only be called by the governance.\\r\\n    function withdrawNotificationReward(address recipient, uint96 amount)\\r\\n        external;\\r\\n\\r\\n    /// @notice Adds staking providers to the slashing queue along with the\\r\\n    ///         amount that should be slashed from each one of them. Can only be\\r\\n    ///         called by application authorized for all staking providers in\\r\\n    ///         the array.\\r\\n    function slash(uint96 amount, address[] memory stakingProviders) external;\\r\\n\\r\\n    /// @notice Adds staking providers to the slashing queue along with the\\r\\n    ///         amount. The notifier will receive reward per each staking\\r\\n    ///         provider from notifiers treasury. Can only be called by\\r\\n    ///         application authorized for all staking providers in the array.\\r\\n    function seize(\\r\\n        uint96 amount,\\r\\n        uint256 rewardMultipier,\\r\\n        address notifier,\\r\\n        address[] memory stakingProviders\\r\\n    ) external;\\r\\n\\r\\n    /// @notice Takes the given number of queued slashing operations and\\r\\n    ///         processes them. Receives 5% of the slashed amount.\\r\\n    ///         Executes `involuntaryAllocationDecrease` function on each\\r\\n    ///         affected application.\\r\\n    function processSlashing(uint256 count) external;\\r\\n\\r\\n    //\\r\\n    //\\r\\n    // Auxiliary functions\\r\\n    //\\r\\n    //\\r\\n\\r\\n    /// @notice Returns the authorized stake amount of the staking provider for\\r\\n    ///         the application.\\r\\n    function authorizedStake(address stakingProvider, address application)\\r\\n        external\\r\\n        view\\r\\n        returns (uint96);\\r\\n\\r\\n    /// @notice Returns staked amount of T, Keep and Nu for the specified\\r\\n    ///         staking provider.\\r\\n    /// @dev    All values are in T denomination\\r\\n    function stakes(address stakingProvider)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint96 tStake,\\r\\n            uint96 keepInTStake,\\r\\n            uint96 nuInTStake\\r\\n        );\\r\\n\\r\\n    /// @notice Returns start staking timestamp.\\r\\n    /// @dev    This value is set at most once.\\r\\n    function getStartStakingTimestamp(address stakingProvider)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    /// @notice Returns staked amount of NU for the specified staking provider.\\r\\n    function stakedNu(address stakingProvider) external view returns (uint256);\\r\\n\\r\\n    /// @notice Gets the stake owner, the beneficiary and the authorizer\\r\\n    ///         for the specified staking provider address.\\r\\n    /// @return owner Stake owner address.\\r\\n    /// @return beneficiary Beneficiary address.\\r\\n    /// @return authorizer Authorizer address.\\r\\n    function rolesOf(address stakingProvider)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            address owner,\\r\\n            address payable beneficiary,\\r\\n            address authorizer\\r\\n        );\\r\\n\\r\\n    /// @notice Returns length of application array\\r\\n    function getApplicationsLength() external view returns (uint256);\\r\\n\\r\\n    /// @notice Returns length of slashing queue\\r\\n    function getSlashingQueueLength() external view returns (uint256);\\r\\n\\r\\n    /// @notice Returns minimum possible stake for T, KEEP or NU in T\\r\\n    ///         denomination.\\r\\n    /// @dev For example, suppose the given staking provider has 10 T, 20 T\\r\\n    ///      worth of KEEP, and 30 T worth of NU all staked, and the maximum\\r\\n    ///      application authorization is 40 T, then `getMinStaked` for\\r\\n    ///      that staking provider returns:\\r\\n    ///          * 0 T if KEEP stake type specified i.e.\\r\\n    ///            min = 40 T max - (10 T + 30 T worth of NU) = 0 T\\r\\n    ///          * 10 T if NU stake type specified i.e.\\r\\n    ///            min = 40 T max - (10 T + 20 T worth of KEEP) = 10 T\\r\\n    ///          * 0 T if T stake type specified i.e.\\r\\n    ///            min = 40 T max - (20 T worth of KEEP + 30 T worth of NU) < 0 T\\r\\n    ///      In other words, the minimum stake amount for the specified\\r\\n    ///      stake type is the minimum amount of stake of the given type\\r\\n    ///      needed to satisfy the maximum application authorization given the\\r\\n    ///      staked amounts of the other stake types for that staking provider.\\r\\n    function getMinStaked(address stakingProvider, StakeType stakeTypes)\\r\\n        external\\r\\n        view\\r\\n        returns (uint96);\\r\\n\\r\\n    /// @notice Returns available amount to authorize for the specified application\\r\\n    function getAvailableToAuthorize(\\r\\n        address stakingProvider,\\r\\n        address application\\r\\n    ) external view returns (uint96);\\r\\n}\\r\\n\",\"keccak256\":\"0x93db77e7f9eb2dad9c5ce471021156abcfda33b193c2c8d3b6ebbb7df303ef73\",\"license\":\"GPL-3.0-or-later\"},\"contracts/staking/KeepStake.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n\\r\\npragma solidity 0.8.9;\\r\\n\\r\\nimport \\\"./ILegacyTokenStaking.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\n/// @title KEEP ManagedGrant contract interface\\r\\ninterface IManagedGrant {\\r\\n    function grantee() external view returns (address);\\r\\n}\\r\\n\\r\\n/// @title KEEP stake owner resolver\\r\\n/// @notice T network staking contract supports existing KEEP stakes by allowing\\r\\n///         KEEP stakers to use their stakes in T network and weights them based\\r\\n///         on KEEP<>T token ratio. KEEP stake owner is cached in T staking\\r\\n///         contract and used to restrict access to all functions only owner or\\r\\n///         operator should call. To cache KEEP stake owner in T staking\\r\\n///         contract, T staking contract first needs to resolve the owner.\\r\\n///\\r\\n///         Resolving liquid KEEP stake owner is easy. Resolving token grant\\r\\n///         stake owner is complicated and not possible to do on-chain from\\r\\n///         a contract external to KEEP TokenStaking contract. Keep TokenStaking\\r\\n///         knows the grant ID but does not expose it externally.\\r\\n///\\r\\n///         KeepStake contract addresses this problem by exposing\\r\\n///         operator-owner mappings snapshotted off-chain based on events and\\r\\n///         information publicly available from KEEP TokenStaking contract and\\r\\n///         KEEP TokenGrant contract. Additionally, it gives the Governance\\r\\n///         ability to add new mappings in case they are ever needed; in\\r\\n///         practice, this will be needed only if someone decides to stake their\\r\\n///         KEEP token grant in KEEP network after 2021-11-11 when the snapshot\\r\\n///         was taken.\\r\\n///\\r\\n///         Operator-owner pairs were snapshotted 2021-11-11 in the following\\r\\n///         way:\\r\\n///         1. Fetch all TokenStaking events from KEEP staking contract.\\r\\n///         2. Filter out undelegated operators.\\r\\n///         3. Filter out canceled delegations.\\r\\n///         4. Fetch grant stake information from KEEP TokenGrant for that\\r\\n///            operator to determine if we are dealing with grant delegation.\\r\\n///         5. Fetch grantee address from KEEP TokenGrant contract.\\r\\n///         6. Check if we are dealing with ManagedGrant by looking for all\\r\\n///            created ManagedGrants and comparing their address against grantee\\r\\n///            address fetched from TokenGrant contract.\\r\\ncontract KeepStake is Ownable {\\r\\n    IKeepTokenStaking public immutable keepTokenStaking;\\r\\n\\r\\n    mapping(address => address) public operatorToManagedGrant;\\r\\n    mapping(address => address) public operatorToGrantee;\\r\\n\\r\\n    constructor(IKeepTokenStaking _keepTokenStaking) {\\r\\n        keepTokenStaking = _keepTokenStaking;\\r\\n    }\\r\\n\\r\\n    /// @notice Allows the Governance to set new operator-managed grant pair.\\r\\n    ///         This function should only be called for managed grants if\\r\\n    ///         the snapshot does include this pair.\\r\\n    function setManagedGrant(address operator, address managedGrant)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        operatorToManagedGrant[operator] = managedGrant;\\r\\n    }\\r\\n\\r\\n    /// @notice Allows the Governance to set new operator-grantee pair.\\r\\n    ///         This function should only be called for non-managed grants if\\r\\n    ///         the snapshot does include this pair.\\r\\n    function setGrantee(address operator, address grantee) external onlyOwner {\\r\\n        operatorToGrantee[operator] = grantee;\\r\\n    }\\r\\n\\r\\n    /// @notice Resolves KEEP stake owner for the provided operator address.\\r\\n    ///         Reverts if could not resolve the owner.\\r\\n    function resolveOwner(address operator) external view returns (address) {\\r\\n        address owner = operatorToManagedGrant[operator];\\r\\n        if (owner != address(0)) {\\r\\n            return IManagedGrant(owner).grantee();\\r\\n        }\\r\\n\\r\\n        owner = operatorToGrantee[operator];\\r\\n        if (owner != address(0)) {\\r\\n            return owner;\\r\\n        }\\r\\n\\r\\n        owner = resolveSnapshottedManagedGrantees(operator);\\r\\n        if (owner != address(0)) {\\r\\n            return owner;\\r\\n        }\\r\\n\\r\\n        owner = resolveSnapshottedGrantees(operator);\\r\\n        if (owner != address(0)) {\\r\\n            return owner;\\r\\n        }\\r\\n\\r\\n        owner = keepTokenStaking.ownerOf(operator);\\r\\n        require(owner != address(0), \\\"Could not resolve the owner\\\");\\r\\n\\r\\n        return owner;\\r\\n    }\\r\\n\\r\\n    function resolveSnapshottedManagedGrantees(address operator)\\r\\n        internal\\r\\n        view\\r\\n        returns (address)\\r\\n    {\\r\\n        if (operator == 0x855A951162B1B93D70724484d5bdc9D00B56236B) {\\r\\n            return\\r\\n                IManagedGrant(0xFADbF758307A054C57B365Db1De90acA71feaFE5)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0xF1De9490Bf7298b5F350cE74332Ad7cf8d5cB181) {\\r\\n            return\\r\\n                IManagedGrant(0xAEd493Aaf3E76E83b29E151848b71eF4544f92f1)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0x39d2aCBCD80d80080541C6eed7e9feBb8127B2Ab) {\\r\\n            return\\r\\n                IManagedGrant(0xA2fa09D6f8C251422F5fde29a0BAd1C53dEfAe66)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0xd66cAE89FfBc6E50e6b019e45c1aEc93Dec54781) {\\r\\n            return\\r\\n                IManagedGrant(0x306309f9d105F34132db0bFB3Ce3f5B0245Cd386)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0x2eBE08379f4fD866E871A9b9E1d5C695154C6A9F) {\\r\\n            return\\r\\n                IManagedGrant(0xd00c0d43b747C33726B3f0ff4BDA4b72dc53c6E9)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0xA97c34278162b556A527CFc01B53eb4DDeDFD223) {\\r\\n            return\\r\\n                IManagedGrant(0xB3E967355c456B1Bd43cB0188A321592D410D096)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0x6C76d49322C9f8761A1623CEd89A31490cdB649d) {\\r\\n            return\\r\\n                IManagedGrant(0xB3E967355c456B1Bd43cB0188A321592D410D096)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0x4a41c7a884d119eaaefE471D0B3a638226408382) {\\r\\n            return\\r\\n                IManagedGrant(0xcdf3d216d82a463Ce82971F2F5DA3d8f9C5f093A)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0x9c06Feb7Ebc8065ee11Cd5E8EEdaAFb2909A7087) {\\r\\n            return\\r\\n                IManagedGrant(0x45119cd98d145283762BA9eBCAea75F72D188733)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0x9bD818Ab6ACC974f2Cf2BD2EBA7a250126Accb9F) {\\r\\n            return\\r\\n                IManagedGrant(0x6E535043377067621954ee84065b0bd7357e7aBa)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0x1d803c89760F8B4057DB15BCb3B8929E0498D310) {\\r\\n            return\\r\\n                IManagedGrant(0xB3E967355c456B1Bd43cB0188A321592D410D096)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0x3101927DEeC27A2bfA6c4a6316e3A221f631dB91) {\\r\\n            return\\r\\n                IManagedGrant(0x178Bf1946feD0e2362fdF8bcD3f91F0701a012C6)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0x9d9b187E478bC62694A7bED216Fc365de87F280C) {\\r\\n            return\\r\\n                IManagedGrant(0xFBad17CFad6cb00D726c65501D69FdC13Ca5477c)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0xd977144724Bc77FaeFAe219F958AE3947205d0b5) {\\r\\n            return\\r\\n                IManagedGrant(0x087B442BFd4E42675cf2df5fa566F87d7A96Fb12)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0x045E511f53DeBF55c9C0B4522f14F602f7C7cA81) {\\r\\n            return\\r\\n                IManagedGrant(0xFcfe8C036C414a15cF871071c483687095caF7D6)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0x3Dd301b3c96A282d8092E1e6f6846f24172D45C1) {\\r\\n            return\\r\\n                IManagedGrant(0xb5Bdd2D9B3541fc8f581Af37430D26527e59aeF8)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0x5d84DEB482E770479154028788Df79aA7C563aA4) {\\r\\n            return\\r\\n                IManagedGrant(0x9D1a179c469a8BdD0b683A9f9250246cc47e8fBE)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0x1dF927B69A97E8140315536163C029d188e8573b) {\\r\\n            return\\r\\n                IManagedGrant(0xb5Bdd2D9B3541fc8f581Af37430D26527e59aeF8)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0x617daCE069Fbd41993491de211b4DfccdAcbd348) {\\r\\n            return\\r\\n                IManagedGrant(0xb5Bdd2D9B3541fc8f581Af37430D26527e59aeF8)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0x650A9eD18Df873cad98C88dcaC8170531cAD2399) {\\r\\n            return\\r\\n                IManagedGrant(0x1Df7324A3aD20526DFa02Cc803eD2D97Cac81F3b)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0x07C9a8f8264221906b7b8958951Ce4753D39628B) {\\r\\n            return\\r\\n                IManagedGrant(0x305D12b4d70529Cd618dA7399F5520701E510041)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0x63eB4c3DD0751F9BE7070A01156513C227fa1eF6) {\\r\\n            return\\r\\n                IManagedGrant(0x306309f9d105F34132db0bFB3Ce3f5B0245Cd386)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0xc6349eEC31048787676b6297ba71721376A8DdcF) {\\r\\n            return\\r\\n                IManagedGrant(0xac1a985E75C6a0b475b9c807Ad0705a988Be2D99)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0x3B945f9C0C8737e44f8e887d4F04B5B3A491Ac4d) {\\r\\n            return\\r\\n                IManagedGrant(0x82e17477726E8D9D2C237745cA9989631582eE98)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0xF35343299a4f80Dd5D917bbe5ddd54eBB820eBd4) {\\r\\n            return\\r\\n                IManagedGrant(0xCC88c15506251B62ccCeebA193e100d6bBC9a30D)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0x3B9e5ae72d068448bB96786989c0d86FBC0551D1) {\\r\\n            return\\r\\n                IManagedGrant(0x306309f9d105F34132db0bFB3Ce3f5B0245Cd386)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0xB2D53Be158Cb8451dFc818bD969877038c1BdeA1) {\\r\\n            return\\r\\n                IManagedGrant(0xaE55e3800f0A3feaFdcE535A8C0fab0fFdB90DEe)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0xF6dbF7AFe05b8Bb6f198eC7e69333c98D3C4608C) {\\r\\n            return\\r\\n                IManagedGrant(0xbb8D24a20c20625f86739824014C3cBAAAb26700)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0xB62Fc1ADfFb2ab832041528C8178358338d85f76) {\\r\\n            return\\r\\n                IManagedGrant(0x9ED98fD1C29018B9342CB8F57A3073B9695f0c02)\\r\\n                    .grantee();\\r\\n        }\\r\\n        if (operator == 0x9bC8d30d971C9e74298112803036C05db07D73e3) {\\r\\n            return\\r\\n                IManagedGrant(0x66beda757939f8e505b5Eb883cd02C8d4a11Bca2)\\r\\n                    .grantee();\\r\\n        }\\r\\n\\r\\n        return address(0);\\r\\n    }\\r\\n\\r\\n    function resolveSnapshottedGrantees(address operator)\\r\\n        internal\\r\\n        pure\\r\\n        returns (address)\\r\\n    {\\r\\n        if (operator == 0x1147ccFB4AEFc6e587a23b78724Ef20Ec6e474D4) {\\r\\n            return 0x3FB49dA4375Ef9019f17990D04c6d5daD482D80a;\\r\\n        }\\r\\n        if (operator == 0x4c21541f95a00C03C75F38C71DC220bd27cbbEd9) {\\r\\n            return 0xC897cfeE43a8d827F76D4226994D5CE5EBBe2571;\\r\\n        }\\r\\n        if (operator == 0x7E6332d18719a5463d3867a1a892359509589a3d) {\\r\\n            return 0x1578eD833D986c1188D1a998aA5FEcD418beF5da;\\r\\n        }\\r\\n        if (operator == 0x8Bd660A764Ca14155F3411a4526a028b6316CB3E) {\\r\\n            return 0xf6f372DfAeCC1431186598c304e91B79Ce115766;\\r\\n        }\\r\\n        if (operator == 0x4F4f0D0dfd93513B3f4Cb116Fe9d0A005466F725) {\\r\\n            return 0x8b055ac1c4dd287E2a46D4a52d61FE76FB551bD0;\\r\\n        }\\r\\n        if (operator == 0x1DF0250027fEC876d8876d1ac7A392c9098F1a1e) {\\r\\n            return 0xE408fFa969707Ce5d7aA3e5F8d44674Fa4b26219;\\r\\n        }\\r\\n        if (operator == 0x860EF3f83B6adFEF757F98345c3B8DdcFCA9d152) {\\r\\n            return 0x08a3633AAb8f3E436DEA204288Ee26Fe094406b0;\\r\\n        }\\r\\n        if (operator == 0xe3a2d16dA142E6B190A5d9F7e0C07cc460B58A5F) {\\r\\n            return 0x875f8fFCDDeD63B5d8Cf54be4E4b82FE6c6E249C;\\r\\n        }\\r\\n        if (operator == 0xBDE07f1cA107Ef319b0Bb26eBF1d0a5b4c97ffc1) {\\r\\n            return 0x1578eD833D986c1188D1a998aA5FEcD418beF5da;\\r\\n        }\\r\\n        if (operator == 0xE86181D6b672d78D33e83029fF3D0ef4A601B4C4) {\\r\\n            return 0x1578eD833D986c1188D1a998aA5FEcD418beF5da;\\r\\n        }\\r\\n        if (operator == 0xb7c561e2069aCaE2c4480111B1606790BB4E13fE) {\\r\\n            return 0x1578eD833D986c1188D1a998aA5FEcD418beF5da;\\r\\n        }\\r\\n        if (operator == 0x526c013f8382B050d32d86e7090Ac84De22EdA4D) {\\r\\n            return 0x61C6E5DDacded540CD08066C08cbc096d22D91f4;\\r\\n        }\\r\\n\\r\\n        return address(0);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xa7a6edd1b38fab63f225bc216a19d6105947c77bf1bb4c6612c2e209091ed44f\",\"license\":\"GPL-3.0-or-later\"},\"contracts/staking/TokenStaking.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n\\r\\npragma solidity 0.8.9;\\r\\n\\r\\nimport \\\"./IApplication.sol\\\";\\r\\nimport \\\"./ILegacyTokenStaking.sol\\\";\\r\\nimport \\\"./IStaking.sol\\\";\\r\\nimport \\\"./KeepStake.sol\\\";\\r\\nimport \\\"../governance/Checkpoints.sol\\\";\\r\\nimport \\\"../token/T.sol\\\";\\r\\nimport \\\"../utils/PercentUtils.sol\\\";\\r\\nimport \\\"../utils/SafeTUpgradeable.sol\\\";\\r\\nimport \\\"../vending/VendingMachine.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\r\\n\\r\\n/// @notice TokenStaking is the main staking contract of the Threshold Network.\\r\\n///         Apart from the basic usage of enabling T stakes, it also acts as a\\r\\n///         sort of \\\"meta-staking\\\" contract, accepting existing legacy NU/KEEP\\r\\n///         stakes. Additionally, it serves as application manager for the apps\\r\\n///         that run on the Threshold Network. Note that legacy NU/KEEP staking\\r\\n///         contracts see TokenStaking as an application (e.g., slashing is\\r\\n///         requested by TokenStaking and performed by the legacy contracts).\\r\\n/// @dev TokenStaking is upgradeable, using OpenZeppelin's Upgradeability\\r\\n///      framework. As such, it is required to satisfy OZ's guidelines, like\\r\\n///      restrictions on constructors, immutable variables, base contracts and\\r\\n///      libraries. See https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\\r\\ncontract TokenStaking is Initializable, IStaking, Checkpoints {\\r\\n    using SafeTUpgradeable for T;\\r\\n    using PercentUtils for uint256;\\r\\n    using SafeCastUpgradeable for uint256;\\r\\n\\r\\n    enum ApplicationStatus {\\r\\n        NOT_APPROVED,\\r\\n        APPROVED,\\r\\n        PAUSED,\\r\\n        DISABLED\\r\\n    }\\r\\n\\r\\n    struct StakingProviderInfo {\\r\\n        uint96 nuInTStake;\\r\\n        address owner;\\r\\n        uint96 keepInTStake;\\r\\n        address payable beneficiary;\\r\\n        uint96 tStake;\\r\\n        address authorizer;\\r\\n        mapping(address => AppAuthorization) authorizations;\\r\\n        address[] authorizedApplications;\\r\\n        uint256 startStakingTimestamp;\\r\\n    }\\r\\n\\r\\n    struct AppAuthorization {\\r\\n        uint96 authorized;\\r\\n        uint96 deauthorizing;\\r\\n    }\\r\\n\\r\\n    struct ApplicationInfo {\\r\\n        ApplicationStatus status;\\r\\n        address panicButton;\\r\\n    }\\r\\n\\r\\n    struct SlashingEvent {\\r\\n        address stakingProvider;\\r\\n        uint96 amount;\\r\\n    }\\r\\n\\r\\n    uint256 internal constant SLASHING_REWARD_PERCENT = 5;\\r\\n    uint256 internal constant MIN_STAKE_TIME = 24 hours;\\r\\n    uint256 internal constant GAS_LIMIT_AUTHORIZATION_DECREASE = 250000;\\r\\n    uint256 internal constant CONVERSION_DIVISOR = 10**(18 - 3);\\r\\n\\r\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\r\\n    T internal immutable token;\\r\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\r\\n    IKeepTokenStaking internal immutable keepStakingContract;\\r\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\r\\n    KeepStake internal immutable keepStake;\\r\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\r\\n    INuCypherStakingEscrow internal immutable nucypherStakingContract;\\r\\n\\r\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\r\\n    uint256 internal immutable keepRatio;\\r\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\r\\n    uint256 internal immutable nucypherRatio;\\r\\n\\r\\n    address public governance;\\r\\n    uint96 public minTStakeAmount;\\r\\n    uint256 public authorizationCeiling;\\r\\n    uint96 public stakeDiscrepancyPenalty;\\r\\n    uint256 public stakeDiscrepancyRewardMultiplier;\\r\\n\\r\\n    uint256 public notifiersTreasury;\\r\\n    uint256 public notificationReward;\\r\\n\\r\\n    mapping(address => StakingProviderInfo) internal stakingProviders;\\r\\n    mapping(address => ApplicationInfo) public applicationInfo;\\r\\n    address[] public applications;\\r\\n\\r\\n    SlashingEvent[] public slashingQueue;\\r\\n    uint256 public slashingQueueIndex;\\r\\n\\r\\n    event Staked(\\r\\n        StakeType indexed stakeType,\\r\\n        address indexed owner,\\r\\n        address indexed stakingProvider,\\r\\n        address beneficiary,\\r\\n        address authorizer,\\r\\n        uint96 amount\\r\\n    );\\r\\n    event MinimumStakeAmountSet(uint96 amount);\\r\\n    event ApplicationStatusChanged(\\r\\n        address indexed application,\\r\\n        ApplicationStatus indexed newStatus\\r\\n    );\\r\\n    event AuthorizationIncreased(\\r\\n        address indexed stakingProvider,\\r\\n        address indexed application,\\r\\n        uint96 fromAmount,\\r\\n        uint96 toAmount\\r\\n    );\\r\\n    event AuthorizationDecreaseRequested(\\r\\n        address indexed stakingProvider,\\r\\n        address indexed application,\\r\\n        uint96 fromAmount,\\r\\n        uint96 toAmount\\r\\n    );\\r\\n    event AuthorizationDecreaseApproved(\\r\\n        address indexed stakingProvider,\\r\\n        address indexed application,\\r\\n        uint96 fromAmount,\\r\\n        uint96 toAmount\\r\\n    );\\r\\n    event AuthorizationInvoluntaryDecreased(\\r\\n        address indexed stakingProvider,\\r\\n        address indexed application,\\r\\n        uint96 fromAmount,\\r\\n        uint96 toAmount,\\r\\n        bool indexed successfulCall\\r\\n    );\\r\\n    event PanicButtonSet(\\r\\n        address indexed application,\\r\\n        address indexed panicButton\\r\\n    );\\r\\n    event AuthorizationCeilingSet(uint256 ceiling);\\r\\n    event ToppedUp(address indexed stakingProvider, uint96 amount);\\r\\n    event Unstaked(address indexed stakingProvider, uint96 amount);\\r\\n    event TokensSeized(\\r\\n        address indexed stakingProvider,\\r\\n        uint96 amount,\\r\\n        bool indexed discrepancy\\r\\n    );\\r\\n    event StakeDiscrepancyPenaltySet(uint96 penalty, uint256 rewardMultiplier);\\r\\n    event NotificationRewardSet(uint96 reward);\\r\\n    event NotificationRewardPushed(uint96 reward);\\r\\n    event NotificationRewardWithdrawn(address recipient, uint96 amount);\\r\\n    event NotifierRewarded(address indexed notifier, uint256 amount);\\r\\n    event SlashingProcessed(\\r\\n        address indexed caller,\\r\\n        uint256 count,\\r\\n        uint256 tAmount\\r\\n    );\\r\\n    event OwnerRefreshed(\\r\\n        address indexed stakingProvider,\\r\\n        address indexed oldOwner,\\r\\n        address indexed newOwner\\r\\n    );\\r\\n    event GovernanceTransferred(address oldGovernance, address newGovernance);\\r\\n\\r\\n    modifier onlyGovernance() {\\r\\n        require(governance == msg.sender, \\\"Caller is not the governance\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyPanicButtonOf(address application) {\\r\\n        require(\\r\\n            applicationInfo[application].panicButton == msg.sender,\\r\\n            \\\"Caller is not the panic button\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyAuthorizerOf(address stakingProvider) {\\r\\n        //slither-disable-next-line incorrect-equality\\r\\n        require(\\r\\n            stakingProviders[stakingProvider].authorizer == msg.sender,\\r\\n            \\\"Not authorizer\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwnerOrStakingProvider(address stakingProvider) {\\r\\n        //slither-disable-next-line incorrect-equality\\r\\n        require(\\r\\n            stakingProviders[stakingProvider].owner != address(0) &&\\r\\n                (stakingProvider == msg.sender ||\\r\\n                    stakingProviders[stakingProvider].owner == msg.sender),\\r\\n            \\\"Not owner or provider\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @param _token Address of T token contract\\r\\n    /// @param _keepStakingContract Address of Keep staking contract\\r\\n    /// @param _nucypherStakingContract Address of NuCypher staking contract\\r\\n    /// @param _keepVendingMachine Address of Keep vending machine\\r\\n    /// @param _nucypherVendingMachine Address of NuCypher vending machine\\r\\n    /// @param _keepStake Address of Keep contract with grant owners\\r\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\r\\n    constructor(\\r\\n        T _token,\\r\\n        IKeepTokenStaking _keepStakingContract,\\r\\n        INuCypherStakingEscrow _nucypherStakingContract,\\r\\n        VendingMachine _keepVendingMachine,\\r\\n        VendingMachine _nucypherVendingMachine,\\r\\n        KeepStake _keepStake\\r\\n    ) {\\r\\n        // calls to check contracts are working\\r\\n        require(\\r\\n            _token.totalSupply() > 0 &&\\r\\n                _keepStakingContract.ownerOf(address(0)) == address(0) &&\\r\\n                _nucypherStakingContract.getAllTokens(address(0)) == 0 &&\\r\\n                AddressUpgradeable.isContract(address(_keepStake)),\\r\\n            \\\"Wrong input parameters\\\"\\r\\n        );\\r\\n        token = _token;\\r\\n        keepStakingContract = _keepStakingContract;\\r\\n        keepStake = _keepStake;\\r\\n        nucypherStakingContract = _nucypherStakingContract;\\r\\n\\r\\n        keepRatio = _keepVendingMachine.ratio();\\r\\n        nucypherRatio = _nucypherVendingMachine.ratio();\\r\\n    }\\r\\n\\r\\n    function initialize() external initializer {\\r\\n        _transferGovernance(msg.sender);\\r\\n    }\\r\\n\\r\\n    //\\r\\n    //\\r\\n    // Delegating a stake\\r\\n    //\\r\\n    //\\r\\n\\r\\n    /// @notice Creates a delegation with `msg.sender` owner with the given\\r\\n    ///         staking provider, beneficiary, and authorizer. Transfers the\\r\\n    ///         given amount of T to the staking contract.\\r\\n    /// @dev The owner of the delegation needs to have the amount approved to\\r\\n    ///      transfer to the staking contract.\\r\\n    function stake(\\r\\n        address stakingProvider,\\r\\n        address payable beneficiary,\\r\\n        address authorizer,\\r\\n        uint96 amount\\r\\n    ) external override {\\r\\n        require(\\r\\n            stakingProvider != address(0) &&\\r\\n                beneficiary != address(0) &&\\r\\n                authorizer != address(0),\\r\\n            \\\"Parameters must be specified\\\"\\r\\n        );\\r\\n        StakingProviderInfo storage stakingProviderStruct = stakingProviders[\\r\\n            stakingProvider\\r\\n        ];\\r\\n        (, uint256 createdAt, ) = keepStakingContract.getDelegationInfo(\\r\\n            stakingProvider\\r\\n        );\\r\\n        require(\\r\\n            createdAt == 0 && stakingProviderStruct.owner == address(0),\\r\\n            \\\"Provider is already in use\\\"\\r\\n        );\\r\\n        require(\\r\\n            amount > 0 && amount >= minTStakeAmount,\\r\\n            \\\"Amount is less than minimum\\\"\\r\\n        );\\r\\n        stakingProviderStruct.owner = msg.sender;\\r\\n        stakingProviderStruct.authorizer = authorizer;\\r\\n        stakingProviderStruct.beneficiary = beneficiary;\\r\\n\\r\\n        stakingProviderStruct.tStake = amount;\\r\\n        /* solhint-disable-next-line not-rely-on-time */\\r\\n        stakingProviderStruct.startStakingTimestamp = block.timestamp;\\r\\n\\r\\n        increaseStakeCheckpoint(stakingProvider, amount);\\r\\n\\r\\n        emit Staked(\\r\\n            StakeType.T,\\r\\n            msg.sender,\\r\\n            stakingProvider,\\r\\n            beneficiary,\\r\\n            authorizer,\\r\\n            amount\\r\\n        );\\r\\n        token.safeTransferFrom(msg.sender, address(this), amount);\\r\\n    }\\r\\n\\r\\n    /// @notice Copies delegation from the legacy KEEP staking contract to T\\r\\n    ///         staking contract. No tokens are transferred. Caches the active\\r\\n    ///         stake amount from KEEP staking contract. Can be called by\\r\\n    ///         anyone.\\r\\n    /// @dev The staking provider in T staking contract is the legacy KEEP\\r\\n    ///      staking contract operator.\\r\\n    function stakeKeep(address stakingProvider) external override {\\r\\n        require(stakingProvider != address(0), \\\"Parameters must be specified\\\");\\r\\n        StakingProviderInfo storage stakingProviderStruct = stakingProviders[\\r\\n            stakingProvider\\r\\n        ];\\r\\n\\r\\n        require(\\r\\n            stakingProviderStruct.owner == address(0),\\r\\n            \\\"Provider is already in use\\\"\\r\\n        );\\r\\n\\r\\n        uint96 tAmount = getKeepAmountInT(stakingProvider);\\r\\n        require(tAmount != 0, \\\"Nothing to sync\\\");\\r\\n\\r\\n        stakingProviderStruct.keepInTStake = tAmount;\\r\\n        stakingProviderStruct.owner = keepStake.resolveOwner(stakingProvider);\\r\\n        stakingProviderStruct.authorizer = keepStakingContract.authorizerOf(\\r\\n            stakingProvider\\r\\n        );\\r\\n        stakingProviderStruct.beneficiary = keepStakingContract.beneficiaryOf(\\r\\n            stakingProvider\\r\\n        );\\r\\n\\r\\n        /* solhint-disable-next-line not-rely-on-time */\\r\\n        stakingProviderStruct.startStakingTimestamp = block.timestamp;\\r\\n\\r\\n        increaseStakeCheckpoint(stakingProvider, tAmount);\\r\\n\\r\\n        emit Staked(\\r\\n            StakeType.KEEP,\\r\\n            stakingProviderStruct.owner,\\r\\n            stakingProvider,\\r\\n            stakingProviderStruct.beneficiary,\\r\\n            stakingProviderStruct.authorizer,\\r\\n            tAmount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Copies delegation from the legacy NU staking contract to T\\r\\n    ///         staking contract, additionally appointing beneficiary and\\r\\n    ///         authorizer roles. Caches the amount staked in NU staking\\r\\n    ///         contract. Can be called only by the original delegation owner.\\r\\n    function stakeNu(\\r\\n        address stakingProvider,\\r\\n        address payable beneficiary,\\r\\n        address authorizer\\r\\n    ) external override {\\r\\n        require(\\r\\n            stakingProvider != address(0) &&\\r\\n                beneficiary != address(0) &&\\r\\n                authorizer != address(0),\\r\\n            \\\"Parameters must be specified\\\"\\r\\n        );\\r\\n        StakingProviderInfo storage stakingProviderStruct = stakingProviders[\\r\\n            stakingProvider\\r\\n        ];\\r\\n        (, uint256 createdAt, ) = keepStakingContract.getDelegationInfo(\\r\\n            stakingProvider\\r\\n        );\\r\\n        require(\\r\\n            createdAt == 0 && stakingProviderStruct.owner == address(0),\\r\\n            \\\"Provider is already in use\\\"\\r\\n        );\\r\\n\\r\\n        uint96 tAmount = getNuAmountInT(msg.sender, stakingProvider);\\r\\n        require(tAmount > 0, \\\"Nothing to sync\\\");\\r\\n\\r\\n        stakingProviderStruct.nuInTStake = tAmount;\\r\\n        stakingProviderStruct.owner = msg.sender;\\r\\n        stakingProviderStruct.authorizer = authorizer;\\r\\n        stakingProviderStruct.beneficiary = beneficiary;\\r\\n        /* solhint-disable-next-line not-rely-on-time */\\r\\n        stakingProviderStruct.startStakingTimestamp = block.timestamp;\\r\\n\\r\\n        increaseStakeCheckpoint(stakingProvider, tAmount);\\r\\n\\r\\n        emit Staked(\\r\\n            StakeType.NU,\\r\\n            msg.sender,\\r\\n            stakingProvider,\\r\\n            beneficiary,\\r\\n            authorizer,\\r\\n            tAmount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Refresh Keep stake owner. Can be called only by the old owner\\r\\n    ///         or their staking provider.\\r\\n    /// @dev The staking provider in T staking contract is the legacy KEEP\\r\\n    ///      staking contract operator.\\r\\n    function refreshKeepStakeOwner(address stakingProvider)\\r\\n        external\\r\\n        override\\r\\n        onlyOwnerOrStakingProvider(stakingProvider)\\r\\n    {\\r\\n        StakingProviderInfo storage stakingProviderStruct = stakingProviders[\\r\\n            stakingProvider\\r\\n        ];\\r\\n        address newOwner = keepStake.resolveOwner(stakingProvider);\\r\\n\\r\\n        emit OwnerRefreshed(\\r\\n            stakingProvider,\\r\\n            stakingProviderStruct.owner,\\r\\n            newOwner\\r\\n        );\\r\\n        stakingProviderStruct.owner = newOwner;\\r\\n    }\\r\\n\\r\\n    /// @notice Allows the Governance to set the minimum required stake amount.\\r\\n    ///         This amount is required to protect against griefing the staking\\r\\n    ///         contract and individual applications are allowed to require\\r\\n    ///         higher minimum stakes if necessary.\\r\\n    /// @dev Staking providers are not required to maintain a minimum T stake\\r\\n    ///      all the time. 24 hours after the delegation, T stake can be reduced\\r\\n    ///      below the minimum stake. The minimum stake in the staking contract\\r\\n    ///      is just to protect against griefing stake operation. Please note\\r\\n    ///      that each application may have its own minimum authorization though\\r\\n    ///      and the authorization can not be higher than the stake.\\r\\n    function setMinimumStakeAmount(uint96 amount)\\r\\n        external\\r\\n        override\\r\\n        onlyGovernance\\r\\n    {\\r\\n        minTStakeAmount = amount;\\r\\n        emit MinimumStakeAmountSet(amount);\\r\\n    }\\r\\n\\r\\n    //\\r\\n    //\\r\\n    // Authorizing an application\\r\\n    //\\r\\n    //\\r\\n\\r\\n    /// @notice Allows the Governance to approve the particular application\\r\\n    ///         before individual stake authorizers are able to authorize it.\\r\\n    function approveApplication(address application)\\r\\n        external\\r\\n        override\\r\\n        onlyGovernance\\r\\n    {\\r\\n        require(application != address(0), \\\"Parameters must be specified\\\");\\r\\n        ApplicationInfo storage info = applicationInfo[application];\\r\\n        require(\\r\\n            info.status == ApplicationStatus.NOT_APPROVED ||\\r\\n                info.status == ApplicationStatus.PAUSED,\\r\\n            \\\"Can't approve application\\\"\\r\\n        );\\r\\n\\r\\n        if (info.status == ApplicationStatus.NOT_APPROVED) {\\r\\n            applications.push(application);\\r\\n        }\\r\\n        info.status = ApplicationStatus.APPROVED;\\r\\n        emit ApplicationStatusChanged(application, ApplicationStatus.APPROVED);\\r\\n    }\\r\\n\\r\\n    /// @notice Increases the authorization of the given staking provider for\\r\\n    ///         the given application by the given amount. Can only be called by\\r\\n    ///         the given staking provider\\u2019s authorizer.\\r\\n    /// @dev Calls `authorizationIncreased` callback on the given application to\\r\\n    ///      notify the application about authorization change.\\r\\n    ///      See `IApplication`.\\r\\n    function increaseAuthorization(\\r\\n        address stakingProvider,\\r\\n        address application,\\r\\n        uint96 amount\\r\\n    ) external override onlyAuthorizerOf(stakingProvider) {\\r\\n        ApplicationInfo storage applicationStruct = applicationInfo[\\r\\n            application\\r\\n        ];\\r\\n        require(\\r\\n            applicationStruct.status == ApplicationStatus.APPROVED,\\r\\n            \\\"Application is not approved\\\"\\r\\n        );\\r\\n\\r\\n        StakingProviderInfo storage stakingProviderStruct = stakingProviders[\\r\\n            stakingProvider\\r\\n        ];\\r\\n        AppAuthorization storage authorization = stakingProviderStruct\\r\\n            .authorizations[application];\\r\\n        uint96 fromAmount = authorization.authorized;\\r\\n        if (fromAmount == 0) {\\r\\n            require(\\r\\n                authorizationCeiling == 0 ||\\r\\n                    stakingProviderStruct.authorizedApplications.length <\\r\\n                    authorizationCeiling,\\r\\n                \\\"Too many applications\\\"\\r\\n            );\\r\\n            stakingProviderStruct.authorizedApplications.push(application);\\r\\n        }\\r\\n\\r\\n        uint96 availableTValue = getAvailableToAuthorize(\\r\\n            stakingProvider,\\r\\n            application\\r\\n        );\\r\\n        require(availableTValue >= amount, \\\"Not enough stake to authorize\\\");\\r\\n        authorization.authorized += amount;\\r\\n        emit AuthorizationIncreased(\\r\\n            stakingProvider,\\r\\n            application,\\r\\n            fromAmount,\\r\\n            authorization.authorized\\r\\n        );\\r\\n        IApplication(application).authorizationIncreased(\\r\\n            stakingProvider,\\r\\n            fromAmount,\\r\\n            authorization.authorized\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Requests decrease of all authorizations for the given staking\\r\\n    ///         provider on all applications by all authorized amount.\\r\\n    ///         It may not change the authorized amount immediatelly. When\\r\\n    ///         it happens depends on the application. Can only be called by the\\r\\n    ///         given staking provider\\u2019s authorizer. Overwrites pending\\r\\n    ///         authorization decrease for the given staking provider and\\r\\n    ///         application.\\r\\n    /// @dev Calls `authorizationDecreaseRequested` callback\\r\\n    ///      for each authorized application. See `IApplication`.\\r\\n    function requestAuthorizationDecrease(address stakingProvider) external {\\r\\n        StakingProviderInfo storage stakingProviderStruct = stakingProviders[\\r\\n            stakingProvider\\r\\n        ];\\r\\n        uint96 deauthorizing = 0;\\r\\n        for (\\r\\n            uint256 i = 0;\\r\\n            i < stakingProviderStruct.authorizedApplications.length;\\r\\n            i++\\r\\n        ) {\\r\\n            address application = stakingProviderStruct.authorizedApplications[\\r\\n                i\\r\\n            ];\\r\\n            uint96 authorized = stakingProviderStruct\\r\\n                .authorizations[application]\\r\\n                .authorized;\\r\\n            if (authorized > 0) {\\r\\n                requestAuthorizationDecrease(\\r\\n                    stakingProvider,\\r\\n                    application,\\r\\n                    authorized\\r\\n                );\\r\\n                deauthorizing += authorized;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        require(deauthorizing > 0, \\\"Nothing was authorized\\\");\\r\\n    }\\r\\n\\r\\n    /// @notice Called by the application at its discretion to approve the\\r\\n    ///         previously requested authorization decrease request. Can only be\\r\\n    ///         called by the application that was previously requested to\\r\\n    ///         decrease the authorization for that staking provider.\\r\\n    ///         Returns resulting authorized amount for the application.\\r\\n    function approveAuthorizationDecrease(address stakingProvider)\\r\\n        external\\r\\n        override\\r\\n        returns (uint96)\\r\\n    {\\r\\n        ApplicationInfo storage applicationStruct = applicationInfo[msg.sender];\\r\\n        require(\\r\\n            applicationStruct.status == ApplicationStatus.APPROVED,\\r\\n            \\\"Application is not approved\\\"\\r\\n        );\\r\\n\\r\\n        StakingProviderInfo storage stakingProviderStruct = stakingProviders[\\r\\n            stakingProvider\\r\\n        ];\\r\\n        AppAuthorization storage authorization = stakingProviderStruct\\r\\n            .authorizations[msg.sender];\\r\\n        require(authorization.deauthorizing > 0, \\\"No deauthorizing in process\\\");\\r\\n\\r\\n        uint96 fromAmount = authorization.authorized;\\r\\n        authorization.authorized -= authorization.deauthorizing;\\r\\n        authorization.deauthorizing = 0;\\r\\n        emit AuthorizationDecreaseApproved(\\r\\n            stakingProvider,\\r\\n            msg.sender,\\r\\n            fromAmount,\\r\\n            authorization.authorized\\r\\n        );\\r\\n\\r\\n        // remove application from an array\\r\\n        if (authorization.authorized == 0) {\\r\\n            cleanAuthorizedApplications(stakingProviderStruct, 1);\\r\\n        }\\r\\n\\r\\n        return authorization.authorized;\\r\\n    }\\r\\n\\r\\n    /// @notice Decreases the authorization for the given `stakingProvider` on\\r\\n    ///         the given disabled `application`, for all authorized amount.\\r\\n    ///         Can be called by anyone.\\r\\n    function forceDecreaseAuthorization(\\r\\n        address stakingProvider,\\r\\n        address application\\r\\n    ) external override {\\r\\n        require(\\r\\n            applicationInfo[application].status == ApplicationStatus.DISABLED,\\r\\n            \\\"Application is not disabled\\\"\\r\\n        );\\r\\n\\r\\n        StakingProviderInfo storage stakingProviderStruct = stakingProviders[\\r\\n            stakingProvider\\r\\n        ];\\r\\n        AppAuthorization storage authorization = stakingProviderStruct\\r\\n            .authorizations[application];\\r\\n        uint96 fromAmount = authorization.authorized;\\r\\n        require(fromAmount > 0, \\\"Application is not authorized\\\");\\r\\n        authorization.authorized = 0;\\r\\n        authorization.deauthorizing = 0;\\r\\n\\r\\n        emit AuthorizationDecreaseApproved(\\r\\n            stakingProvider,\\r\\n            application,\\r\\n            fromAmount,\\r\\n            0\\r\\n        );\\r\\n        cleanAuthorizedApplications(stakingProviderStruct, 1);\\r\\n    }\\r\\n\\r\\n    /// @notice Pauses the given application\\u2019s eligibility to slash stakes.\\r\\n    ///         Besides that stakers can't change authorization to the application.\\r\\n    ///         Can be called only by the Panic Button of the particular\\r\\n    ///         application. The paused application can not slash stakes until\\r\\n    ///         it is approved again by the Governance using `approveApplication`\\r\\n    ///         function. Should be used only in case of an emergency.\\r\\n    function pauseApplication(address application)\\r\\n        external\\r\\n        override\\r\\n        onlyPanicButtonOf(application)\\r\\n    {\\r\\n        ApplicationInfo storage applicationStruct = applicationInfo[\\r\\n            application\\r\\n        ];\\r\\n        require(\\r\\n            applicationStruct.status == ApplicationStatus.APPROVED,\\r\\n            \\\"Can't pause application\\\"\\r\\n        );\\r\\n        applicationStruct.status = ApplicationStatus.PAUSED;\\r\\n        emit ApplicationStatusChanged(application, ApplicationStatus.PAUSED);\\r\\n    }\\r\\n\\r\\n    /// @notice Disables the given application. The disabled application can't\\r\\n    ///         slash stakers. Also stakers can't increase authorization to that\\r\\n    ///         application but can decrease without waiting by calling\\r\\n    ///         `forceDecreaseAuthorization` at any moment. Can be called only\\r\\n    ///         by the governance. The disabled application can't be approved\\r\\n    ///         again. Should be used only in case of an emergency.\\r\\n    function disableApplication(address application)\\r\\n        external\\r\\n        override\\r\\n        onlyGovernance\\r\\n    {\\r\\n        ApplicationInfo storage applicationStruct = applicationInfo[\\r\\n            application\\r\\n        ];\\r\\n        require(\\r\\n            applicationStruct.status == ApplicationStatus.APPROVED ||\\r\\n                applicationStruct.status == ApplicationStatus.PAUSED,\\r\\n            \\\"Can't disable application\\\"\\r\\n        );\\r\\n        applicationStruct.status = ApplicationStatus.DISABLED;\\r\\n        emit ApplicationStatusChanged(application, ApplicationStatus.DISABLED);\\r\\n    }\\r\\n\\r\\n    /// @notice Sets the Panic Button role for the given application to the\\r\\n    ///         provided address. Can only be called by the Governance. If the\\r\\n    ///         Panic Button for the given application should be disabled, the\\r\\n    ///         role address should be set to 0x0 address.\\r\\n    function setPanicButton(address application, address panicButton)\\r\\n        external\\r\\n        override\\r\\n        onlyGovernance\\r\\n    {\\r\\n        ApplicationInfo storage applicationStruct = applicationInfo[\\r\\n            application\\r\\n        ];\\r\\n        require(\\r\\n            applicationStruct.status == ApplicationStatus.APPROVED,\\r\\n            \\\"Application is not approved\\\"\\r\\n        );\\r\\n        applicationStruct.panicButton = panicButton;\\r\\n        emit PanicButtonSet(application, panicButton);\\r\\n    }\\r\\n\\r\\n    /// @notice Sets the maximum number of applications one staking provider can\\r\\n    ///         have authorized. Used to protect against DoSing slashing queue.\\r\\n    ///         Can only be called by the Governance.\\r\\n    function setAuthorizationCeiling(uint256 ceiling)\\r\\n        external\\r\\n        override\\r\\n        onlyGovernance\\r\\n    {\\r\\n        authorizationCeiling = ceiling;\\r\\n        emit AuthorizationCeilingSet(ceiling);\\r\\n    }\\r\\n\\r\\n    //\\r\\n    //\\r\\n    // Stake top-up\\r\\n    //\\r\\n    //\\r\\n\\r\\n    /// @notice Increases the amount of the stake for the given staking provider.\\r\\n    /// @dev The sender of this transaction needs to have the amount approved to\\r\\n    ///      transfer to the staking contract.\\r\\n    function topUp(address stakingProvider, uint96 amount) external override {\\r\\n        require(\\r\\n            stakingProviders[stakingProvider].owner != address(0),\\r\\n            \\\"Nothing to top-up\\\"\\r\\n        );\\r\\n        require(amount > 0, \\\"Parameters must be specified\\\");\\r\\n        StakingProviderInfo storage stakingProviderStruct = stakingProviders[\\r\\n            stakingProvider\\r\\n        ];\\r\\n        stakingProviderStruct.tStake += amount;\\r\\n        emit ToppedUp(stakingProvider, amount);\\r\\n        increaseStakeCheckpoint(stakingProvider, amount);\\r\\n        token.safeTransferFrom(msg.sender, address(this), amount);\\r\\n    }\\r\\n\\r\\n    /// @notice Propagates information about stake top-up from the legacy KEEP\\r\\n    ///         staking contract to T staking contract. Can be called only by\\r\\n    ///         the owner or the staking provider.\\r\\n    function topUpKeep(address stakingProvider)\\r\\n        external\\r\\n        override\\r\\n        onlyOwnerOrStakingProvider(stakingProvider)\\r\\n    {\\r\\n        StakingProviderInfo storage stakingProviderStruct = stakingProviders[\\r\\n            stakingProvider\\r\\n        ];\\r\\n        uint96 tAmount = getKeepAmountInT(stakingProvider);\\r\\n        require(\\r\\n            tAmount > stakingProviderStruct.keepInTStake,\\r\\n            \\\"Nothing to top-up\\\"\\r\\n        );\\r\\n\\r\\n        uint96 toppedUp = tAmount - stakingProviderStruct.keepInTStake;\\r\\n        emit ToppedUp(stakingProvider, toppedUp);\\r\\n        stakingProviderStruct.keepInTStake = tAmount;\\r\\n        increaseStakeCheckpoint(stakingProvider, toppedUp);\\r\\n    }\\r\\n\\r\\n    /// @notice Propagates information about stake top-up from the legacy NU\\r\\n    ///         staking contract to T staking contract. Can be called only by\\r\\n    ///         the owner or the staking provider.\\r\\n    function topUpNu(address stakingProvider)\\r\\n        external\\r\\n        override\\r\\n        onlyOwnerOrStakingProvider(stakingProvider)\\r\\n    {\\r\\n        StakingProviderInfo storage stakingProviderStruct = stakingProviders[\\r\\n            stakingProvider\\r\\n        ];\\r\\n        uint96 tAmount = getNuAmountInT(\\r\\n            stakingProviderStruct.owner,\\r\\n            stakingProvider\\r\\n        );\\r\\n        require(\\r\\n            tAmount > stakingProviderStruct.nuInTStake,\\r\\n            \\\"Nothing to top-up\\\"\\r\\n        );\\r\\n\\r\\n        uint96 toppedUp = tAmount - stakingProviderStruct.nuInTStake;\\r\\n        emit ToppedUp(stakingProvider, toppedUp);\\r\\n        stakingProviderStruct.nuInTStake = tAmount;\\r\\n        increaseStakeCheckpoint(stakingProvider, toppedUp);\\r\\n    }\\r\\n\\r\\n    //\\r\\n    //\\r\\n    // Undelegating a stake (unstaking)\\r\\n    //\\r\\n    //\\r\\n\\r\\n    /// @notice Reduces the liquid T stake amount by the provided amount and\\r\\n    ///         withdraws T to the owner. Reverts if there is at least one\\r\\n    ///         authorization higher than the sum of the legacy stake and\\r\\n    ///         remaining liquid T stake or if the unstake amount is higher than\\r\\n    ///         the liquid T stake amount. Can be called only by the owner or\\r\\n    ///         the staking provider. Can only be called when 24h passed since\\r\\n    ///         the stake has been delegated.\\r\\n    function unstakeT(address stakingProvider, uint96 amount)\\r\\n        external\\r\\n        override\\r\\n        onlyOwnerOrStakingProvider(stakingProvider)\\r\\n    {\\r\\n        StakingProviderInfo storage stakingProviderStruct = stakingProviders[\\r\\n            stakingProvider\\r\\n        ];\\r\\n        require(\\r\\n            amount > 0 &&\\r\\n                amount + getMinStaked(stakingProvider, StakeType.T) <=\\r\\n                stakingProviderStruct.tStake,\\r\\n            \\\"Too much to unstake\\\"\\r\\n        );\\r\\n        require(\\r\\n            stakingProviderStruct.startStakingTimestamp + MIN_STAKE_TIME <=\\r\\n                /* solhint-disable-next-line not-rely-on-time */\\r\\n                block.timestamp,\\r\\n            \\\"Can't unstake earlier than 24h\\\"\\r\\n        );\\r\\n\\r\\n        stakingProviderStruct.tStake -= amount;\\r\\n        decreaseStakeCheckpoint(stakingProvider, amount);\\r\\n        emit Unstaked(stakingProvider, amount);\\r\\n        token.safeTransfer(stakingProviderStruct.owner, amount);\\r\\n    }\\r\\n\\r\\n    /// @notice Sets the legacy KEEP staking contract active stake amount cached\\r\\n    ///         in T staking contract to 0. Reverts if the amount of liquid T\\r\\n    ///         staked in T staking contract is lower than the highest\\r\\n    ///         application authorization. This function allows to unstake from\\r\\n    ///         KEEP staking contract and still being able to operate in T\\r\\n    ///         network and earning rewards based on the liquid T staked. Can be\\r\\n    ///         called only by the delegation owner or the staking provider.\\r\\n    ///         Can only be called when 24h passed since the stake has been\\r\\n    ///         delegated.\\r\\n    /// @dev    This function (or `unstakeAll`) must be called before\\r\\n    ///         `undelegate`/`undelegateAt` in Keep staking contract. Otherwise\\r\\n    ///         provider can be slashed by `notifyKeepStakeDiscrepancy` method.\\r\\n    function unstakeKeep(address stakingProvider)\\r\\n        external\\r\\n        override\\r\\n        onlyOwnerOrStakingProvider(stakingProvider)\\r\\n    {\\r\\n        StakingProviderInfo storage stakingProviderStruct = stakingProviders[\\r\\n            stakingProvider\\r\\n        ];\\r\\n        uint96 keepInTStake = stakingProviderStruct.keepInTStake;\\r\\n        require(keepInTStake != 0, \\\"Nothing to unstake\\\");\\r\\n        require(\\r\\n            getMinStaked(stakingProvider, StakeType.KEEP) == 0,\\r\\n            \\\"Keep stake still authorized\\\"\\r\\n        );\\r\\n        require(\\r\\n            stakingProviderStruct.startStakingTimestamp + MIN_STAKE_TIME <=\\r\\n                /* solhint-disable-next-line not-rely-on-time */\\r\\n                block.timestamp,\\r\\n            \\\"Can't unstake earlier than 24h\\\"\\r\\n        );\\r\\n\\r\\n        emit Unstaked(stakingProvider, keepInTStake);\\r\\n        stakingProviderStruct.keepInTStake = 0;\\r\\n        decreaseStakeCheckpoint(stakingProvider, keepInTStake);\\r\\n    }\\r\\n\\r\\n    /// @notice Reduces cached legacy NU stake amount by the provided amount.\\r\\n    ///         Reverts if there is at least one authorization higher than the\\r\\n    ///         sum of remaining legacy NU stake and liquid T stake for that\\r\\n    ///         staking provider or if the untaked amount is higher than the\\r\\n    ///         cached legacy stake amount. If succeeded, the legacy NU stake\\r\\n    ///         can be partially or fully undelegated on the legacy staking\\r\\n    ///         contract. This function allows to unstake from NU staking\\r\\n    ///         contract and still being able to operate in T network and\\r\\n    ///         earning rewards based on the liquid T staked. Can be called only\\r\\n    ///         by the delegation owner or the staking provider. Can only be\\r\\n    ///         called when 24h passed since the stake has been delegated.\\r\\n    /// @dev    This function (or `unstakeAll`) must be called before `withdraw`\\r\\n    ///         in NuCypher staking contract. Otherwise NU tokens can't be\\r\\n    ///         unlocked.\\r\\n    /// @param stakingProvider Staking provider address\\r\\n    /// @param amount Amount of NU to unstake in T denomination\\r\\n    function unstakeNu(address stakingProvider, uint96 amount)\\r\\n        external\\r\\n        override\\r\\n        onlyOwnerOrStakingProvider(stakingProvider)\\r\\n    {\\r\\n        StakingProviderInfo storage stakingProviderStruct = stakingProviders[\\r\\n            stakingProvider\\r\\n        ];\\r\\n        // rounding amount to guarantee exact T<>NU conversion in both ways,\\r\\n        // so there's no remainder after unstaking\\r\\n        (, uint96 tRemainder) = convertFromT(amount, nucypherRatio);\\r\\n        amount -= tRemainder;\\r\\n        require(\\r\\n            amount > 0 &&\\r\\n                amount + getMinStaked(stakingProvider, StakeType.NU) <=\\r\\n                stakingProviderStruct.nuInTStake,\\r\\n            \\\"Too much to unstake\\\"\\r\\n        );\\r\\n        require(\\r\\n            stakingProviderStruct.startStakingTimestamp + MIN_STAKE_TIME <=\\r\\n                /* solhint-disable-next-line not-rely-on-time */\\r\\n                block.timestamp,\\r\\n            \\\"Can't unstake earlier than 24h\\\"\\r\\n        );\\r\\n\\r\\n        stakingProviderStruct.nuInTStake -= amount;\\r\\n        decreaseStakeCheckpoint(stakingProvider, amount);\\r\\n        emit Unstaked(stakingProvider, amount);\\r\\n    }\\r\\n\\r\\n    /// @notice Sets cached legacy stake amount to 0, sets the liquid T stake\\r\\n    ///         amount to 0 and withdraws all liquid T from the stake to the\\r\\n    ///         owner. Reverts if there is at least one non-zero authorization.\\r\\n    ///         Can be called only by the delegation owner or the staking\\r\\n    ///         provider. Can only be called when 24h passed since the stake\\r\\n    ///         has been delegated.\\r\\n    function unstakeAll(address stakingProvider)\\r\\n        external\\r\\n        override\\r\\n        onlyOwnerOrStakingProvider(stakingProvider)\\r\\n    {\\r\\n        StakingProviderInfo storage stakingProviderStruct = stakingProviders[\\r\\n            stakingProvider\\r\\n        ];\\r\\n        require(\\r\\n            stakingProviderStruct.authorizedApplications.length == 0,\\r\\n            \\\"Stake still authorized\\\"\\r\\n        );\\r\\n        require(\\r\\n            stakingProviderStruct.startStakingTimestamp + MIN_STAKE_TIME <=\\r\\n                /* solhint-disable-next-line not-rely-on-time */\\r\\n                block.timestamp,\\r\\n            \\\"Can't unstake earlier than 24h\\\"\\r\\n        );\\r\\n\\r\\n        uint96 unstaked = stakingProviderStruct.tStake +\\r\\n            stakingProviderStruct.keepInTStake +\\r\\n            stakingProviderStruct.nuInTStake;\\r\\n        emit Unstaked(stakingProvider, unstaked);\\r\\n        uint96 amount = stakingProviderStruct.tStake;\\r\\n        stakingProviderStruct.tStake = 0;\\r\\n        stakingProviderStruct.keepInTStake = 0;\\r\\n        stakingProviderStruct.nuInTStake = 0;\\r\\n        decreaseStakeCheckpoint(stakingProvider, unstaked);\\r\\n\\r\\n        if (amount > 0) {\\r\\n            token.safeTransfer(stakingProviderStruct.owner, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //\\r\\n    //\\r\\n    // Keeping information in sync\\r\\n    //\\r\\n    //\\r\\n\\r\\n    /// @notice Notifies about the discrepancy between legacy KEEP active stake\\r\\n    ///         and the amount cached in T staking contract. Slashes the staking\\r\\n    ///         provider in case the amount cached is higher than the actual\\r\\n    ///         active stake amount in KEEP staking contract. Needs to update\\r\\n    ///         authorizations of all affected applications and execute an\\r\\n    ///         involuntary authorization decrease on all affected applications.\\r\\n    ///         Can be called by anyone, notifier receives a reward.\\r\\n    function notifyKeepStakeDiscrepancy(address stakingProvider)\\r\\n        external\\r\\n        override\\r\\n    {\\r\\n        StakingProviderInfo storage stakingProviderStruct = stakingProviders[\\r\\n            stakingProvider\\r\\n        ];\\r\\n        require(stakingProviderStruct.keepInTStake > 0, \\\"Nothing to slash\\\");\\r\\n\\r\\n        (uint256 keepStakeAmount, , uint256 undelegatedAt) = keepStakingContract\\r\\n            .getDelegationInfo(stakingProvider);\\r\\n\\r\\n        (uint96 realKeepInTStake, ) = convertToT(keepStakeAmount, keepRatio);\\r\\n        uint96 oldKeepInTStake = stakingProviderStruct.keepInTStake;\\r\\n\\r\\n        require(\\r\\n            oldKeepInTStake > realKeepInTStake || undelegatedAt != 0,\\r\\n            \\\"There is no discrepancy\\\"\\r\\n        );\\r\\n        stakingProviderStruct.keepInTStake = realKeepInTStake;\\r\\n        seizeKeep(\\r\\n            stakingProviderStruct,\\r\\n            stakingProvider,\\r\\n            stakeDiscrepancyPenalty,\\r\\n            stakeDiscrepancyRewardMultiplier\\r\\n        );\\r\\n\\r\\n        uint96 slashedAmount = realKeepInTStake -\\r\\n            stakingProviderStruct.keepInTStake;\\r\\n        emit TokensSeized(stakingProvider, slashedAmount, true);\\r\\n        if (undelegatedAt != 0) {\\r\\n            stakingProviderStruct.keepInTStake = 0;\\r\\n        }\\r\\n\\r\\n        decreaseStakeCheckpoint(\\r\\n            stakingProvider,\\r\\n            oldKeepInTStake - stakingProviderStruct.keepInTStake\\r\\n        );\\r\\n\\r\\n        authorizationDecrease(\\r\\n            stakingProvider,\\r\\n            stakingProviderStruct,\\r\\n            slashedAmount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Notifies about the discrepancy between legacy NU active stake\\r\\n    ///         and the amount cached in T staking contract. Slashes the\\r\\n    ///         staking provider in case the amount cached is higher than the\\r\\n    ///         actual active stake amount in NU staking contract. Needs to\\r\\n    ///         update authorizations of all affected applications and execute an\\r\\n    ///         involuntary authorization decrease on all affected applications.\\r\\n    ///         Can be called by anyone, notifier receives a reward.\\r\\n    /// @dev    Real discrepancy between T and Nu is impossible.\\r\\n    ///         This method is a safeguard in case of bugs in NuCypher staking\\r\\n    ///         contract\\r\\n    function notifyNuStakeDiscrepancy(address stakingProvider)\\r\\n        external\\r\\n        override\\r\\n    {\\r\\n        StakingProviderInfo storage stakingProviderStruct = stakingProviders[\\r\\n            stakingProvider\\r\\n        ];\\r\\n        require(stakingProviderStruct.nuInTStake > 0, \\\"Nothing to slash\\\");\\r\\n\\r\\n        uint256 nuStakeAmount = nucypherStakingContract.getAllTokens(\\r\\n            stakingProviderStruct.owner\\r\\n        );\\r\\n        (uint96 realNuInTStake, ) = convertToT(nuStakeAmount, nucypherRatio);\\r\\n        uint96 oldNuInTStake = stakingProviderStruct.nuInTStake;\\r\\n        require(oldNuInTStake > realNuInTStake, \\\"There is no discrepancy\\\");\\r\\n\\r\\n        stakingProviderStruct.nuInTStake = realNuInTStake;\\r\\n        seizeNu(\\r\\n            stakingProviderStruct,\\r\\n            stakeDiscrepancyPenalty,\\r\\n            stakeDiscrepancyRewardMultiplier\\r\\n        );\\r\\n\\r\\n        uint96 slashedAmount = realNuInTStake -\\r\\n            stakingProviderStruct.nuInTStake;\\r\\n        emit TokensSeized(stakingProvider, slashedAmount, true);\\r\\n        authorizationDecrease(\\r\\n            stakingProvider,\\r\\n            stakingProviderStruct,\\r\\n            slashedAmount\\r\\n        );\\r\\n        decreaseStakeCheckpoint(\\r\\n            stakingProvider,\\r\\n            oldNuInTStake - stakingProviderStruct.nuInTStake\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Sets the penalty amount for stake discrepancy and reward\\r\\n    ///         multiplier for reporting it. The penalty is seized from the\\r\\n    ///         delegated stake, and 5% of the penalty, scaled by the\\r\\n    ///         multiplier, is given to the notifier. The rest of the tokens are\\r\\n    ///         burned. Can only be called by the Governance. See `seize` function.\\r\\n    function setStakeDiscrepancyPenalty(\\r\\n        uint96 penalty,\\r\\n        uint256 rewardMultiplier\\r\\n    ) external override onlyGovernance {\\r\\n        stakeDiscrepancyPenalty = penalty;\\r\\n        stakeDiscrepancyRewardMultiplier = rewardMultiplier;\\r\\n        emit StakeDiscrepancyPenaltySet(penalty, rewardMultiplier);\\r\\n    }\\r\\n\\r\\n    /// @notice Sets reward in T tokens for notification of misbehaviour\\r\\n    ///         of one staking provider. Can only be called by the governance.\\r\\n    function setNotificationReward(uint96 reward)\\r\\n        external\\r\\n        override\\r\\n        onlyGovernance\\r\\n    {\\r\\n        notificationReward = reward;\\r\\n        emit NotificationRewardSet(reward);\\r\\n    }\\r\\n\\r\\n    /// @notice Transfer some amount of T tokens as reward for notifications\\r\\n    ///         of misbehaviour\\r\\n    function pushNotificationReward(uint96 reward) external override {\\r\\n        require(reward > 0, \\\"Parameters must be specified\\\");\\r\\n        notifiersTreasury += reward;\\r\\n        emit NotificationRewardPushed(reward);\\r\\n        token.safeTransferFrom(msg.sender, address(this), reward);\\r\\n    }\\r\\n\\r\\n    /// @notice Withdraw some amount of T tokens from notifiers treasury.\\r\\n    ///         Can only be called by the governance.\\r\\n    function withdrawNotificationReward(address recipient, uint96 amount)\\r\\n        external\\r\\n        override\\r\\n        onlyGovernance\\r\\n    {\\r\\n        require(amount <= notifiersTreasury, \\\"Not enough tokens\\\");\\r\\n        notifiersTreasury -= amount;\\r\\n        emit NotificationRewardWithdrawn(recipient, amount);\\r\\n        token.safeTransfer(recipient, amount);\\r\\n    }\\r\\n\\r\\n    /// @notice Adds staking providers to the slashing queue along with the\\r\\n    ///         amount that should be slashed from each one of them. Can only be\\r\\n    ///         called by application authorized for all staking providers in\\r\\n    ///         the array.\\r\\n    /// @dev    This method doesn't emit events for providers that are added to\\r\\n    ///         the queue. If necessary  events can be added to the application\\r\\n    ///         level.\\r\\n    function slash(uint96 amount, address[] memory _stakingProviders)\\r\\n        external\\r\\n        override\\r\\n    {\\r\\n        notify(amount, 0, address(0), _stakingProviders);\\r\\n    }\\r\\n\\r\\n    /// @notice Adds staking providers to the slashing queue along with the\\r\\n    ///         amount. The notifier will receive reward per each provider from\\r\\n    ///         notifiers treasury. Can only be called by application\\r\\n    ///         authorized for all staking providers in the array.\\r\\n    /// @dev    This method doesn't emit events for staking providers that are\\r\\n    ///         added to the queue. If necessary  events can be added to the\\r\\n    ///         application level.\\r\\n    function seize(\\r\\n        uint96 amount,\\r\\n        uint256 rewardMultiplier,\\r\\n        address notifier,\\r\\n        address[] memory _stakingProviders\\r\\n    ) external override {\\r\\n        notify(amount, rewardMultiplier, notifier, _stakingProviders);\\r\\n    }\\r\\n\\r\\n    /// @notice Takes the given number of queued slashing operations and\\r\\n    ///         processes them. Receives 5% of the slashed amount.\\r\\n    ///         Executes `involuntaryAuthorizationDecrease` function on each\\r\\n    ///         affected application.\\r\\n    function processSlashing(uint256 count) external virtual override {\\r\\n        require(\\r\\n            slashingQueueIndex < slashingQueue.length && count > 0,\\r\\n            \\\"Nothing to process\\\"\\r\\n        );\\r\\n\\r\\n        uint256 maxIndex = slashingQueueIndex + count;\\r\\n        maxIndex = MathUpgradeable.min(maxIndex, slashingQueue.length);\\r\\n        count = maxIndex - slashingQueueIndex;\\r\\n        uint96 tAmountToBurn = 0;\\r\\n\\r\\n        uint256 index = slashingQueueIndex;\\r\\n        for (; index < maxIndex; index++) {\\r\\n            SlashingEvent storage slashing = slashingQueue[index];\\r\\n            tAmountToBurn += processSlashing(slashing);\\r\\n        }\\r\\n        slashingQueueIndex = index;\\r\\n\\r\\n        uint256 tProcessorReward = uint256(tAmountToBurn).percent(\\r\\n            SLASHING_REWARD_PERCENT\\r\\n        );\\r\\n        notifiersTreasury += tAmountToBurn - tProcessorReward.toUint96();\\r\\n        emit SlashingProcessed(msg.sender, count, tProcessorReward);\\r\\n        if (tProcessorReward > 0) {\\r\\n            token.safeTransfer(msg.sender, tProcessorReward);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Delegate voting power from the stake associated to the\\r\\n    ///         `stakingProvider` to a `delegatee` address. Caller must be the\\r\\n    ///         owner of this stake.\\r\\n    function delegateVoting(address stakingProvider, address delegatee)\\r\\n        external\\r\\n    {\\r\\n        delegate(stakingProvider, delegatee);\\r\\n    }\\r\\n\\r\\n    /// @notice Transfers ownership of the contract to `newGuvnor`.\\r\\n    function transferGovernance(address newGuvnor)\\r\\n        external\\r\\n        virtual\\r\\n        onlyGovernance\\r\\n    {\\r\\n        _transferGovernance(newGuvnor);\\r\\n    }\\r\\n\\r\\n    //\\r\\n    //\\r\\n    // Auxiliary functions\\r\\n    //\\r\\n    //\\r\\n\\r\\n    /// @notice Returns the authorized stake amount of the staking provider for\\r\\n    ///         the application.\\r\\n    function authorizedStake(address stakingProvider, address application)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (uint96)\\r\\n    {\\r\\n        return\\r\\n            stakingProviders[stakingProvider]\\r\\n                .authorizations[application]\\r\\n                .authorized;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns staked amount of T, Keep and Nu for the specified\\r\\n    ///         staking provider.\\r\\n    /// @dev    All values are in T denomination\\r\\n    function stakes(address stakingProvider)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (\\r\\n            uint96 tStake,\\r\\n            uint96 keepInTStake,\\r\\n            uint96 nuInTStake\\r\\n        )\\r\\n    {\\r\\n        StakingProviderInfo storage stakingProviderStruct = stakingProviders[\\r\\n            stakingProvider\\r\\n        ];\\r\\n        tStake = stakingProviderStruct.tStake;\\r\\n        keepInTStake = stakingProviderStruct.keepInTStake;\\r\\n        nuInTStake = stakingProviderStruct.nuInTStake;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns start staking timestamp.\\r\\n    /// @dev    This value is set at most once.\\r\\n    function getStartStakingTimestamp(address stakingProvider)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return stakingProviders[stakingProvider].startStakingTimestamp;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns staked amount of NU for the specified staking provider.\\r\\n    function stakedNu(address stakingProvider)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (uint256 nuAmount)\\r\\n    {\\r\\n        (nuAmount, ) = convertFromT(\\r\\n            stakingProviders[stakingProvider].nuInTStake,\\r\\n            nucypherRatio\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Gets the stake owner, the beneficiary and the authorizer\\r\\n    ///         for the specified staking provider address.\\r\\n    /// @return owner Stake owner address.\\r\\n    /// @return beneficiary Beneficiary address.\\r\\n    /// @return authorizer Authorizer address.\\r\\n    function rolesOf(address stakingProvider)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (\\r\\n            address owner,\\r\\n            address payable beneficiary,\\r\\n            address authorizer\\r\\n        )\\r\\n    {\\r\\n        StakingProviderInfo storage stakingProviderStruct = stakingProviders[\\r\\n            stakingProvider\\r\\n        ];\\r\\n        owner = stakingProviderStruct.owner;\\r\\n        beneficiary = stakingProviderStruct.beneficiary;\\r\\n        authorizer = stakingProviderStruct.authorizer;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns length of application array\\r\\n    function getApplicationsLength() external view override returns (uint256) {\\r\\n        return applications.length;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns length of slashing queue\\r\\n    function getSlashingQueueLength() external view override returns (uint256) {\\r\\n        return slashingQueue.length;\\r\\n    }\\r\\n\\r\\n    /// @notice Requests decrease of the authorization for the given staking\\r\\n    ///         provider on the given application by the provided amount.\\r\\n    ///         It may not change the authorized amount immediatelly. When\\r\\n    ///         it happens depends on the application. Can only be called by the\\r\\n    ///         given staking provider\\u2019s authorizer. Overwrites pending\\r\\n    ///         authorization decrease for the given staking provider and\\r\\n    ///         application if the application agrees for that. If the\\r\\n    ///         application does not agree for overwriting, the function\\r\\n    ///         reverts.\\r\\n    /// @dev Calls `authorizationDecreaseRequested` callback on the given\\r\\n    ///      application. See `IApplication`.\\r\\n    function requestAuthorizationDecrease(\\r\\n        address stakingProvider,\\r\\n        address application,\\r\\n        uint96 amount\\r\\n    ) public override onlyAuthorizerOf(stakingProvider) {\\r\\n        ApplicationInfo storage applicationStruct = applicationInfo[\\r\\n            application\\r\\n        ];\\r\\n        require(\\r\\n            applicationStruct.status == ApplicationStatus.APPROVED,\\r\\n            \\\"Application is not approved\\\"\\r\\n        );\\r\\n\\r\\n        require(amount > 0, \\\"Parameters must be specified\\\");\\r\\n\\r\\n        AppAuthorization storage authorization = stakingProviders[\\r\\n            stakingProvider\\r\\n        ].authorizations[application];\\r\\n        require(\\r\\n            authorization.authorized >= amount,\\r\\n            \\\"Amount exceeds authorized\\\"\\r\\n        );\\r\\n\\r\\n        authorization.deauthorizing = amount;\\r\\n        uint96 deauthorizingTo = authorization.authorized - amount;\\r\\n        emit AuthorizationDecreaseRequested(\\r\\n            stakingProvider,\\r\\n            application,\\r\\n            authorization.authorized,\\r\\n            deauthorizingTo\\r\\n        );\\r\\n        IApplication(application).authorizationDecreaseRequested(\\r\\n            stakingProvider,\\r\\n            authorization.authorized,\\r\\n            deauthorizingTo\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Returns minimum possible stake for T, KEEP or NU in T denomination\\r\\n    /// @dev For example, suppose the given staking provider has 10 T, 20 T worth\\r\\n    ///      of KEEP, and 30 T worth of NU all staked, and the maximum\\r\\n    ///      application authorization is 40 T, then `getMinStaked` for\\r\\n    ///      that staking provider returns:\\r\\n    ///          * 0 T if KEEP stake type specified i.e.\\r\\n    ///            min = 40 T max - (10 T + 30 T worth of NU) = 0 T\\r\\n    ///          * 10 T if NU stake type specified i.e.\\r\\n    ///            min = 40 T max - (10 T + 20 T worth of KEEP) = 10 T\\r\\n    ///          * 0 T if T stake type specified i.e.\\r\\n    ///            min = 40 T max - (20 T worth of KEEP + 30 T worth of NU) < 0 T\\r\\n    ///      In other words, the minimum stake amount for the specified\\r\\n    ///      stake type is the minimum amount of stake of the given type\\r\\n    ///      needed to satisfy the maximum application authorization given\\r\\n    ///      the staked amounts of the other stake types for that staking\\r\\n    ///      provider.\\r\\n    function getMinStaked(address stakingProvider, StakeType stakeTypes)\\r\\n        public\\r\\n        view\\r\\n        override\\r\\n        returns (uint96)\\r\\n    {\\r\\n        StakingProviderInfo storage stakingProviderStruct = stakingProviders[\\r\\n            stakingProvider\\r\\n        ];\\r\\n        uint256 maxAuthorization = 0;\\r\\n        for (\\r\\n            uint256 i = 0;\\r\\n            i < stakingProviderStruct.authorizedApplications.length;\\r\\n            i++\\r\\n        ) {\\r\\n            address application = stakingProviderStruct.authorizedApplications[\\r\\n                i\\r\\n            ];\\r\\n            maxAuthorization = MathUpgradeable.max(\\r\\n                maxAuthorization,\\r\\n                stakingProviderStruct.authorizations[application].authorized\\r\\n            );\\r\\n        }\\r\\n\\r\\n        if (maxAuthorization == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        if (stakeTypes != StakeType.T) {\\r\\n            maxAuthorization -= MathUpgradeable.min(\\r\\n                maxAuthorization,\\r\\n                stakingProviderStruct.tStake\\r\\n            );\\r\\n        }\\r\\n        if (stakeTypes != StakeType.NU) {\\r\\n            maxAuthorization -= MathUpgradeable.min(\\r\\n                maxAuthorization,\\r\\n                stakingProviderStruct.nuInTStake\\r\\n            );\\r\\n        }\\r\\n        if (stakeTypes != StakeType.KEEP) {\\r\\n            maxAuthorization -= MathUpgradeable.min(\\r\\n                maxAuthorization,\\r\\n                stakingProviderStruct.keepInTStake\\r\\n            );\\r\\n        }\\r\\n        return maxAuthorization.toUint96();\\r\\n    }\\r\\n\\r\\n    /// @notice Returns available amount to authorize for the specified\\r\\n    ///         application.\\r\\n    function getAvailableToAuthorize(\\r\\n        address stakingProvider,\\r\\n        address application\\r\\n    ) public view override returns (uint96 availableTValue) {\\r\\n        StakingProviderInfo storage stakingProviderStruct = stakingProviders[\\r\\n            stakingProvider\\r\\n        ];\\r\\n        availableTValue =\\r\\n            stakingProviderStruct.tStake +\\r\\n            stakingProviderStruct.keepInTStake +\\r\\n            stakingProviderStruct.nuInTStake;\\r\\n        availableTValue -= stakingProviderStruct\\r\\n            .authorizations[application]\\r\\n            .authorized;\\r\\n    }\\r\\n\\r\\n    /// @notice Delegate voting power from the stake associated to the\\r\\n    ///         `stakingProvider` to a `delegatee` address. Caller must be the owner\\r\\n    ///         of this stake.\\r\\n    /// @dev Original abstract function defined in Checkpoints contract had two\\r\\n    ///      parameters, `delegator` and `delegatee`. Here we override it and\\r\\n    ///      comply with the same signature but the semantics of the first\\r\\n    ///      parameter changes to the `stakingProvider` address.\\r\\n    function delegate(address stakingProvider, address delegatee)\\r\\n        internal\\r\\n        virtual\\r\\n        override\\r\\n    {\\r\\n        StakingProviderInfo storage stakingProviderStruct = stakingProviders[\\r\\n            stakingProvider\\r\\n        ];\\r\\n        require(\\r\\n            stakingProviderStruct.owner == msg.sender,\\r\\n            \\\"Caller is not owner\\\"\\r\\n        );\\r\\n        uint96 stakingProviderBalance = stakingProviderStruct.tStake +\\r\\n            stakingProviderStruct.keepInTStake +\\r\\n            stakingProviderStruct.nuInTStake;\\r\\n        address oldDelegatee = delegates(stakingProvider);\\r\\n        _delegates[stakingProvider] = delegatee;\\r\\n        emit DelegateChanged(stakingProvider, oldDelegatee, delegatee);\\r\\n        moveVotingPower(oldDelegatee, delegatee, stakingProviderBalance);\\r\\n    }\\r\\n\\r\\n    /// @notice Adds staking providers to the slashing queue along with the\\r\\n    ///         amount. The notifier will receive reward per each staking\\r\\n    ///         provider from notifiers treasury. Can only be called by\\r\\n    ///         application authorized for all staking providers in the array.\\r\\n    function notify(\\r\\n        uint96 amount,\\r\\n        uint256 rewardMultiplier,\\r\\n        address notifier,\\r\\n        address[] memory _stakingProviders\\r\\n    ) internal {\\r\\n        require(\\r\\n            amount > 0 && _stakingProviders.length > 0,\\r\\n            \\\"Parameters must be specified\\\"\\r\\n        );\\r\\n\\r\\n        ApplicationInfo storage applicationStruct = applicationInfo[msg.sender];\\r\\n        require(\\r\\n            applicationStruct.status == ApplicationStatus.APPROVED,\\r\\n            \\\"Application is not approved\\\"\\r\\n        );\\r\\n\\r\\n        uint256 queueLength = slashingQueue.length;\\r\\n        for (uint256 i = 0; i < _stakingProviders.length; i++) {\\r\\n            address stakingProvider = _stakingProviders[i];\\r\\n            uint256 amountToSlash = MathUpgradeable.min(\\r\\n                stakingProviders[stakingProvider]\\r\\n                    .authorizations[msg.sender]\\r\\n                    .authorized,\\r\\n                amount\\r\\n            );\\r\\n            if (\\r\\n                //slither-disable-next-line incorrect-equality\\r\\n                amountToSlash == 0\\r\\n            ) {\\r\\n                continue;\\r\\n            }\\r\\n            slashingQueue.push(\\r\\n                SlashingEvent(stakingProvider, amountToSlash.toUint96())\\r\\n            );\\r\\n        }\\r\\n\\r\\n        if (notifier != address(0)) {\\r\\n            uint256 reward = ((slashingQueue.length - queueLength) *\\r\\n                notificationReward).percent(rewardMultiplier);\\r\\n            reward = MathUpgradeable.min(reward, notifiersTreasury);\\r\\n            emit NotifierRewarded(notifier, reward);\\r\\n            if (reward != 0) {\\r\\n                notifiersTreasury -= reward;\\r\\n                token.safeTransfer(notifier, reward);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Processes one specified slashing event.\\r\\n    ///         Executes `involuntaryAuthorizationDecrease` function on each\\r\\n    ///         affected application.\\r\\n    //slither-disable-next-line dead-code\\r\\n    function processSlashing(SlashingEvent storage slashing)\\r\\n        internal\\r\\n        returns (uint96 tAmountToBurn)\\r\\n    {\\r\\n        StakingProviderInfo storage stakingProviderStruct = stakingProviders[\\r\\n            slashing.stakingProvider\\r\\n        ];\\r\\n        uint96 tAmountToSlash = slashing.amount;\\r\\n        uint96 oldStake = stakingProviderStruct.tStake +\\r\\n            stakingProviderStruct.keepInTStake +\\r\\n            stakingProviderStruct.nuInTStake;\\r\\n        // slash T\\r\\n        if (stakingProviderStruct.tStake > 0) {\\r\\n            if (tAmountToSlash <= stakingProviderStruct.tStake) {\\r\\n                tAmountToBurn = tAmountToSlash;\\r\\n            } else {\\r\\n                tAmountToBurn = stakingProviderStruct.tStake;\\r\\n            }\\r\\n            stakingProviderStruct.tStake -= tAmountToBurn;\\r\\n            tAmountToSlash -= tAmountToBurn;\\r\\n        }\\r\\n\\r\\n        // slash KEEP\\r\\n        if (tAmountToSlash > 0 && stakingProviderStruct.keepInTStake > 0) {\\r\\n            (uint256 keepStakeAmount, , ) = keepStakingContract\\r\\n                .getDelegationInfo(slashing.stakingProvider);\\r\\n            (uint96 tAmount, ) = convertToT(keepStakeAmount, keepRatio);\\r\\n            stakingProviderStruct.keepInTStake = tAmount;\\r\\n\\r\\n            tAmountToSlash = seizeKeep(\\r\\n                stakingProviderStruct,\\r\\n                slashing.stakingProvider,\\r\\n                tAmountToSlash,\\r\\n                100\\r\\n            );\\r\\n        }\\r\\n\\r\\n        // slash NU\\r\\n        if (tAmountToSlash > 0 && stakingProviderStruct.nuInTStake > 0) {\\r\\n            // synchronization skipped due to impossibility of real discrepancy\\r\\n            tAmountToSlash = seizeNu(\\r\\n                stakingProviderStruct,\\r\\n                tAmountToSlash,\\r\\n                100\\r\\n            );\\r\\n        }\\r\\n\\r\\n        uint96 slashedAmount = slashing.amount - tAmountToSlash;\\r\\n        emit TokensSeized(slashing.stakingProvider, slashedAmount, false);\\r\\n        authorizationDecrease(\\r\\n            slashing.stakingProvider,\\r\\n            stakingProviderStruct,\\r\\n            slashedAmount\\r\\n        );\\r\\n        uint96 newStake = stakingProviderStruct.tStake +\\r\\n            stakingProviderStruct.keepInTStake +\\r\\n            stakingProviderStruct.nuInTStake;\\r\\n        decreaseStakeCheckpoint(slashing.stakingProvider, oldStake - newStake);\\r\\n    }\\r\\n\\r\\n    /// @notice Synchronize authorizations (if needed) after slashing stake\\r\\n    function authorizationDecrease(\\r\\n        address stakingProvider,\\r\\n        StakingProviderInfo storage stakingProviderStruct,\\r\\n        uint96 slashedAmount\\r\\n    ) internal {\\r\\n        uint96 totalStake = stakingProviderStruct.tStake +\\r\\n            stakingProviderStruct.nuInTStake +\\r\\n            stakingProviderStruct.keepInTStake;\\r\\n        uint256 applicationsToDelete = 0;\\r\\n        for (\\r\\n            uint256 i = 0;\\r\\n            i < stakingProviderStruct.authorizedApplications.length;\\r\\n            i++\\r\\n        ) {\\r\\n            address authorizedApplication = stakingProviderStruct\\r\\n                .authorizedApplications[i];\\r\\n            AppAuthorization storage authorization = stakingProviderStruct\\r\\n                .authorizations[authorizedApplication];\\r\\n            uint96 fromAmount = authorization.authorized;\\r\\n\\r\\n            authorization.authorized -= MathUpgradeable\\r\\n                .min(fromAmount, slashedAmount)\\r\\n                .toUint96();\\r\\n\\r\\n            if (authorization.authorized > totalStake) {\\r\\n                authorization.authorized = totalStake;\\r\\n            }\\r\\n\\r\\n            bool successful = true;\\r\\n            //slither-disable-next-line calls-loop\\r\\n            try\\r\\n                IApplication(authorizedApplication)\\r\\n                    .involuntaryAuthorizationDecrease{\\r\\n                    gas: GAS_LIMIT_AUTHORIZATION_DECREASE\\r\\n                }(stakingProvider, fromAmount, authorization.authorized)\\r\\n            {} catch {\\r\\n                successful = false;\\r\\n            }\\r\\n            if (authorization.deauthorizing > authorization.authorized) {\\r\\n                authorization.deauthorizing = authorization.authorized;\\r\\n            }\\r\\n            emit AuthorizationInvoluntaryDecreased(\\r\\n                stakingProvider,\\r\\n                authorizedApplication,\\r\\n                fromAmount,\\r\\n                authorization.authorized,\\r\\n                successful\\r\\n            );\\r\\n            if (authorization.authorized == 0) {\\r\\n                applicationsToDelete++;\\r\\n            }\\r\\n        }\\r\\n        if (applicationsToDelete > 0) {\\r\\n            cleanAuthorizedApplications(\\r\\n                stakingProviderStruct,\\r\\n                applicationsToDelete\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Convert amount from T to Keep and call `seize` in Keep staking contract.\\r\\n    ///         Returns remainder of slashing amount in T\\r\\n    /// @dev Note this internal function doesn't update stake checkpoints\\r\\n    function seizeKeep(\\r\\n        StakingProviderInfo storage stakingProviderStruct,\\r\\n        address stakingProvider,\\r\\n        uint96 tAmountToSlash,\\r\\n        uint256 rewardMultiplier\\r\\n    ) internal returns (uint96) {\\r\\n        if (stakingProviderStruct.keepInTStake == 0) {\\r\\n            return tAmountToSlash;\\r\\n        }\\r\\n\\r\\n        uint96 tPenalty;\\r\\n        if (tAmountToSlash <= stakingProviderStruct.keepInTStake) {\\r\\n            tPenalty = tAmountToSlash;\\r\\n        } else {\\r\\n            tPenalty = stakingProviderStruct.keepInTStake;\\r\\n        }\\r\\n\\r\\n        (uint256 keepPenalty, uint96 tRemainder) = convertFromT(\\r\\n            tPenalty,\\r\\n            keepRatio\\r\\n        );\\r\\n        if (keepPenalty == 0) {\\r\\n            return tAmountToSlash;\\r\\n        }\\r\\n        tPenalty -= tRemainder;\\r\\n        stakingProviderStruct.keepInTStake -= tPenalty;\\r\\n        tAmountToSlash -= tPenalty;\\r\\n\\r\\n        address[] memory stakingProviderWrapper = new address[](1);\\r\\n        stakingProviderWrapper[0] = stakingProvider;\\r\\n        keepStakingContract.seize(\\r\\n            keepPenalty,\\r\\n            rewardMultiplier,\\r\\n            msg.sender,\\r\\n            stakingProviderWrapper\\r\\n        );\\r\\n        return tAmountToSlash;\\r\\n    }\\r\\n\\r\\n    /// @notice Convert amount from T to NU and call `slashStaker` in NuCypher staking contract.\\r\\n    ///         Returns remainder of slashing amount in T\\r\\n    /// @dev Note this internal function doesn't update the stake checkpoints\\r\\n    function seizeNu(\\r\\n        StakingProviderInfo storage stakingProviderStruct,\\r\\n        uint96 tAmountToSlash,\\r\\n        uint256 rewardMultiplier\\r\\n    ) internal returns (uint96) {\\r\\n        if (stakingProviderStruct.nuInTStake == 0) {\\r\\n            return tAmountToSlash;\\r\\n        }\\r\\n\\r\\n        uint96 tPenalty;\\r\\n        if (tAmountToSlash <= stakingProviderStruct.nuInTStake) {\\r\\n            tPenalty = tAmountToSlash;\\r\\n        } else {\\r\\n            tPenalty = stakingProviderStruct.nuInTStake;\\r\\n        }\\r\\n\\r\\n        (uint256 nuPenalty, uint96 tRemainder) = convertFromT(\\r\\n            tPenalty,\\r\\n            nucypherRatio\\r\\n        );\\r\\n        if (nuPenalty == 0) {\\r\\n            return tAmountToSlash;\\r\\n        }\\r\\n        tPenalty -= tRemainder;\\r\\n        stakingProviderStruct.nuInTStake -= tPenalty;\\r\\n        tAmountToSlash -= tPenalty;\\r\\n\\r\\n        uint256 nuReward = nuPenalty.percent(SLASHING_REWARD_PERCENT).percent(\\r\\n            rewardMultiplier\\r\\n        );\\r\\n        nucypherStakingContract.slashStaker(\\r\\n            stakingProviderStruct.owner,\\r\\n            nuPenalty,\\r\\n            msg.sender,\\r\\n            nuReward\\r\\n        );\\r\\n        return tAmountToSlash;\\r\\n    }\\r\\n\\r\\n    /// @notice Removes application with zero authorization from authorized\\r\\n    ///         applications array\\r\\n    function cleanAuthorizedApplications(\\r\\n        StakingProviderInfo storage stakingProviderStruct,\\r\\n        uint256 numberToDelete\\r\\n    ) internal {\\r\\n        uint256 length = stakingProviderStruct.authorizedApplications.length;\\r\\n        if (numberToDelete == length) {\\r\\n            delete stakingProviderStruct.authorizedApplications;\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        uint256 deleted = 0;\\r\\n        uint256 index = 0;\\r\\n        uint256 newLength = length - numberToDelete;\\r\\n        while (index < newLength && deleted < numberToDelete) {\\r\\n            address application = stakingProviderStruct.authorizedApplications[\\r\\n                index\\r\\n            ];\\r\\n            if (\\r\\n                stakingProviderStruct.authorizations[application].authorized ==\\r\\n                0\\r\\n            ) {\\r\\n                stakingProviderStruct.authorizedApplications[\\r\\n                        index\\r\\n                    ] = stakingProviderStruct.authorizedApplications[\\r\\n                    length - deleted - 1\\r\\n                ];\\r\\n                deleted++;\\r\\n            } else {\\r\\n                index++;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (index = newLength; index < length; index++) {\\r\\n            stakingProviderStruct.authorizedApplications.pop();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Creates new checkpoints due to a change of stake amount\\r\\n    /// @param _delegator Address of the staking provider acting as delegator\\r\\n    /// @param _amount Amount of T to increment\\r\\n    /// @param increase True if the change is an increase, false if a decrease\\r\\n    function newStakeCheckpoint(\\r\\n        address _delegator,\\r\\n        uint96 _amount,\\r\\n        bool increase\\r\\n    ) internal {\\r\\n        if (_amount == 0) {\\r\\n            return;\\r\\n        }\\r\\n        writeCheckpoint(\\r\\n            _totalSupplyCheckpoints,\\r\\n            increase ? add : subtract,\\r\\n            _amount\\r\\n        );\\r\\n        address delegatee = delegates(_delegator);\\r\\n        if (delegatee != address(0)) {\\r\\n            (uint256 oldWeight, uint256 newWeight) = writeCheckpoint(\\r\\n                _checkpoints[delegatee],\\r\\n                increase ? add : subtract,\\r\\n                _amount\\r\\n            );\\r\\n            emit DelegateVotesChanged(delegatee, oldWeight, newWeight);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Creates new checkpoints due to an increment of a stakers' stake\\r\\n    /// @param _delegator Address of the staking provider acting as delegator\\r\\n    /// @param _amount Amount of T to increment\\r\\n    function increaseStakeCheckpoint(address _delegator, uint96 _amount)\\r\\n        internal\\r\\n    {\\r\\n        newStakeCheckpoint(_delegator, _amount, true);\\r\\n    }\\r\\n\\r\\n    /// @notice Creates new checkpoints due to a decrease of a stakers' stake\\r\\n    /// @param _delegator Address of the stake owner acting as delegator\\r\\n    /// @param _amount Amount of T to decrease\\r\\n    function decreaseStakeCheckpoint(address _delegator, uint96 _amount)\\r\\n        internal\\r\\n    {\\r\\n        newStakeCheckpoint(_delegator, _amount, false);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns amount of Nu stake in the NuCypher staking contract for\\r\\n    ///         the specified staking provider.\\r\\n    ///         Resulting value in T denomination\\r\\n    function getNuAmountInT(address owner, address stakingProvider)\\r\\n        internal\\r\\n        returns (uint96)\\r\\n    {\\r\\n        uint256 nuStakeAmount = nucypherStakingContract.requestMerge(\\r\\n            owner,\\r\\n            stakingProvider\\r\\n        );\\r\\n        (uint96 tAmount, ) = convertToT(nuStakeAmount, nucypherRatio);\\r\\n        return tAmount;\\r\\n    }\\r\\n\\r\\n    function _transferGovernance(address newGuvnor) internal virtual {\\r\\n        address oldGuvnor = governance;\\r\\n        governance = newGuvnor;\\r\\n        emit GovernanceTransferred(oldGuvnor, newGuvnor);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns amount of Keep stake in the Keep staking contract for\\r\\n    ///         the specified staking provider.\\r\\n    ///         Resulting value in T denomination\\r\\n    function getKeepAmountInT(address stakingProvider)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint96)\\r\\n    {\\r\\n        uint256 keepStakeAmount = keepStakingContract.eligibleStake(\\r\\n            stakingProvider,\\r\\n            address(this)\\r\\n        );\\r\\n        (uint96 tAmount, ) = convertToT(keepStakeAmount, keepRatio);\\r\\n        return tAmount;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the T token amount that's obtained from `amount` legacy\\r\\n    ///         tokens for the given `ratio`, and the remainder that can't be\\r\\n    ///         converted.\\r\\n    function convertToT(uint256 amount, uint256 ratio)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint96 tAmount, uint256 remainder)\\r\\n    {\\r\\n        remainder = amount % CONVERSION_DIVISOR;\\r\\n        uint256 convertibleAmount = amount - remainder;\\r\\n        tAmount = ((convertibleAmount * ratio) / CONVERSION_DIVISOR).toUint96();\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the amount of legacy tokens that's obtained from\\r\\n    ///         `tAmount` T tokens for the given `ratio`, and the T remainder\\r\\n    ///         that can't be converted.\\r\\n    function convertFromT(uint96 tAmount, uint256 ratio)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256 amount, uint96 tRemainder)\\r\\n    {\\r\\n        //slither-disable-next-line weak-prng\\r\\n        tRemainder = (tAmount % ratio).toUint96();\\r\\n        uint256 convertibleAmount = tAmount - tRemainder;\\r\\n        amount = (convertibleAmount * CONVERSION_DIVISOR) / ratio;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x1730b21d1497cda2ed5892112d5faddb542242b2dd42b2086b351280b9d4aadc\",\"license\":\"GPL-3.0-or-later\"},\"contracts/test/TokenStakingTestSet.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\npragma solidity 0.8.9;\\r\\n\\r\\nimport \\\"../staking/ILegacyTokenStaking.sol\\\";\\r\\nimport \\\"../staking/IApplication.sol\\\";\\r\\nimport \\\"../staking/TokenStaking.sol\\\";\\r\\n\\r\\ncontract KeepTokenStakingMock is IKeepTokenStaking {\\r\\n    using PercentUtils for uint256;\\r\\n\\r\\n    struct OperatorStruct {\\r\\n        address owner;\\r\\n        address payable beneficiary;\\r\\n        address authorizer;\\r\\n        uint256 createdAt;\\r\\n        uint256 undelegatedAt;\\r\\n        uint256 amount;\\r\\n        mapping(address => bool) eligibility;\\r\\n    }\\r\\n\\r\\n    mapping(address => OperatorStruct) internal operators;\\r\\n    mapping(address => uint256) public tattletales;\\r\\n\\r\\n    function setOperator(\\r\\n        address operator,\\r\\n        address owner,\\r\\n        address payable beneficiary,\\r\\n        address authorizer,\\r\\n        uint256 createdAt,\\r\\n        uint256 undelegatedAt,\\r\\n        uint256 amount\\r\\n    ) external {\\r\\n        OperatorStruct storage operatorStrut = operators[operator];\\r\\n        operatorStrut.owner = owner;\\r\\n        operatorStrut.beneficiary = beneficiary;\\r\\n        operatorStrut.authorizer = authorizer;\\r\\n        operatorStrut.createdAt = createdAt;\\r\\n        operatorStrut.undelegatedAt = undelegatedAt;\\r\\n        operatorStrut.amount = amount;\\r\\n    }\\r\\n\\r\\n    function setEligibility(\\r\\n        address operator,\\r\\n        address application,\\r\\n        bool isEligible\\r\\n    ) external {\\r\\n        operators[operator].eligibility[application] = isEligible;\\r\\n    }\\r\\n\\r\\n    function setAmount(address operator, uint256 amount) external {\\r\\n        operators[operator].amount = amount;\\r\\n    }\\r\\n\\r\\n    function setUndelegatedAt(address operator, uint256 undelegatedAt)\\r\\n        external\\r\\n    {\\r\\n        operators[operator].undelegatedAt = undelegatedAt;\\r\\n    }\\r\\n\\r\\n    function seize(\\r\\n        uint256 amountToSeize,\\r\\n        uint256 rewardMultiplier,\\r\\n        address tattletale,\\r\\n        address[] memory misbehavedOperators\\r\\n    ) external override {\\r\\n        require(amountToSeize > 0, \\\"Amount to slash must be greater than zero\\\");\\r\\n        // assumed only one will be slashed (per call)\\r\\n        require(\\r\\n            misbehavedOperators.length == 1,\\r\\n            \\\"Only one operator per call in tests\\\"\\r\\n        );\\r\\n        address operator = misbehavedOperators[0];\\r\\n        operators[operator].amount -= amountToSeize;\\r\\n        tattletales[tattletale] += amountToSeize.percent(5).percent(\\r\\n            rewardMultiplier\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function getDelegationInfo(address operator)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (\\r\\n            uint256 amount,\\r\\n            uint256 createdAt,\\r\\n            uint256 undelegatedAt\\r\\n        )\\r\\n    {\\r\\n        amount = operators[operator].amount;\\r\\n        createdAt = operators[operator].createdAt;\\r\\n        undelegatedAt = operators[operator].undelegatedAt;\\r\\n    }\\r\\n\\r\\n    function ownerOf(address operator)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (address)\\r\\n    {\\r\\n        return operators[operator].owner;\\r\\n    }\\r\\n\\r\\n    function beneficiaryOf(address operator)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (address payable)\\r\\n    {\\r\\n        return operators[operator].beneficiary;\\r\\n    }\\r\\n\\r\\n    function authorizerOf(address operator)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (address)\\r\\n    {\\r\\n        return operators[operator].authorizer;\\r\\n    }\\r\\n\\r\\n    function eligibleStake(address operator, address operatorContract)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (uint256 balance)\\r\\n    {\\r\\n        OperatorStruct storage operatorStrut = operators[operator];\\r\\n        if (operatorStrut.eligibility[operatorContract]) {\\r\\n            return operatorStrut.amount;\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract NuCypherTokenStakingMock is INuCypherStakingEscrow {\\r\\n    struct StakerStruct {\\r\\n        uint256 value;\\r\\n        address stakingProvider;\\r\\n    }\\r\\n\\r\\n    mapping(address => StakerStruct) public stakers;\\r\\n    mapping(address => uint256) public investigators;\\r\\n\\r\\n    function setStaker(address staker, uint256 value) external {\\r\\n        stakers[staker].value = value;\\r\\n    }\\r\\n\\r\\n    function slashStaker(\\r\\n        address staker,\\r\\n        uint256 penalty,\\r\\n        address investigator,\\r\\n        uint256 reward\\r\\n    ) external override {\\r\\n        require(penalty > 0, \\\"Amount to slash must be greater than zero\\\");\\r\\n        stakers[staker].value -= penalty;\\r\\n        investigators[investigator] += reward;\\r\\n    }\\r\\n\\r\\n    function requestMerge(address staker, address stakingProvider)\\r\\n        external\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        StakerStruct storage stakerStruct = stakers[staker];\\r\\n        require(\\r\\n            stakerStruct.stakingProvider == address(0) ||\\r\\n                stakerStruct.stakingProvider == stakingProvider,\\r\\n            \\\"Another provider was already set for this staker\\\"\\r\\n        );\\r\\n        if (stakerStruct.stakingProvider == address(0)) {\\r\\n            stakerStruct.stakingProvider = stakingProvider;\\r\\n        }\\r\\n        return stakers[staker].value;\\r\\n    }\\r\\n\\r\\n    function getAllTokens(address staker)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return stakers[staker].value;\\r\\n    }\\r\\n\\r\\n    function stakerInfo(address staker)\\r\\n        public\\r\\n        view\\r\\n        returns (StakerStruct memory)\\r\\n    {\\r\\n        return stakers[staker];\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract VendingMachineMock {\\r\\n    uint256 public constant FLOATING_POINT_DIVISOR = 10**15;\\r\\n\\r\\n    uint256 public immutable ratio;\\r\\n\\r\\n    constructor(uint96 _wrappedTokenAllocation, uint96 _tTokenAllocation) {\\r\\n        ratio =\\r\\n            (FLOATING_POINT_DIVISOR * _tTokenAllocation) /\\r\\n            _wrappedTokenAllocation;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract ApplicationMock is IApplication {\\r\\n    struct StakingProviderStruct {\\r\\n        uint96 authorized;\\r\\n        uint96 deauthorizingTo;\\r\\n    }\\r\\n\\r\\n    TokenStaking internal immutable tokenStaking;\\r\\n    mapping(address => StakingProviderStruct) public stakingProviders;\\r\\n\\r\\n    constructor(TokenStaking _tokenStaking) {\\r\\n        tokenStaking = _tokenStaking;\\r\\n    }\\r\\n\\r\\n    function withdrawRewards(address) external {\\r\\n        // does nothing\\r\\n    }\\r\\n\\r\\n    function authorizationIncreased(\\r\\n        address stakingProvider,\\r\\n        uint96,\\r\\n        uint96 toAmount\\r\\n    ) external override {\\r\\n        stakingProviders[stakingProvider].authorized = toAmount;\\r\\n    }\\r\\n\\r\\n    function authorizationDecreaseRequested(\\r\\n        address stakingProvider,\\r\\n        uint96,\\r\\n        uint96 toAmount\\r\\n    ) external override {\\r\\n        stakingProviders[stakingProvider].deauthorizingTo = toAmount;\\r\\n    }\\r\\n\\r\\n    function approveAuthorizationDecrease(address stakingProvider) external {\\r\\n        StakingProviderStruct storage stakingProviderStruct = stakingProviders[\\r\\n            stakingProvider\\r\\n        ];\\r\\n        stakingProviderStruct.authorized = tokenStaking\\r\\n            .approveAuthorizationDecrease(stakingProvider);\\r\\n    }\\r\\n\\r\\n    function slash(uint96 amount, address[] memory _stakingProviders) external {\\r\\n        tokenStaking.slash(amount, _stakingProviders);\\r\\n    }\\r\\n\\r\\n    function seize(\\r\\n        uint96 amount,\\r\\n        uint256 rewardMultiplier,\\r\\n        address notifier,\\r\\n        address[] memory _stakingProviders\\r\\n    ) external {\\r\\n        tokenStaking.seize(\\r\\n            amount,\\r\\n            rewardMultiplier,\\r\\n            notifier,\\r\\n            _stakingProviders\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function involuntaryAuthorizationDecrease(\\r\\n        address stakingProvider,\\r\\n        uint96,\\r\\n        uint96 toAmount\\r\\n    ) public virtual override {\\r\\n        StakingProviderStruct storage stakingProviderStruct = stakingProviders[\\r\\n            stakingProvider\\r\\n        ];\\r\\n        require(\\r\\n            toAmount != stakingProviderStruct.authorized,\\r\\n            \\\"Nothing to decrease\\\"\\r\\n        );\\r\\n        uint96 decrease = stakingProviderStruct.authorized - toAmount;\\r\\n        if (stakingProviderStruct.deauthorizingTo > decrease) {\\r\\n            stakingProviderStruct.deauthorizingTo -= decrease;\\r\\n        } else {\\r\\n            stakingProviderStruct.deauthorizingTo = 0;\\r\\n        }\\r\\n        stakingProviderStruct.authorized = toAmount;\\r\\n    }\\r\\n\\r\\n    function availableRewards(address) external pure returns (uint96) {\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    function minimumAuthorization() external pure returns (uint96) {\\r\\n        return 0;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract BrokenApplicationMock is ApplicationMock {\\r\\n    constructor(TokenStaking _tokenStaking) ApplicationMock(_tokenStaking) {}\\r\\n\\r\\n    function involuntaryAuthorizationDecrease(\\r\\n        address,\\r\\n        uint96,\\r\\n        uint96\\r\\n    ) public pure override {\\r\\n        revert(\\\"Broken application\\\");\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract ExpensiveApplicationMock is ApplicationMock {\\r\\n    uint256[] private dummy;\\r\\n\\r\\n    constructor(TokenStaking _tokenStaking) ApplicationMock(_tokenStaking) {}\\r\\n\\r\\n    function involuntaryAuthorizationDecrease(\\r\\n        address stakingProvider,\\r\\n        uint96 fromAmount,\\r\\n        uint96 toAmount\\r\\n    ) public override {\\r\\n        super.involuntaryAuthorizationDecrease(\\r\\n            stakingProvider,\\r\\n            fromAmount,\\r\\n            toAmount\\r\\n        );\\r\\n        for (uint256 i = 0; i < 12; i++) {\\r\\n            dummy.push(i);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract ManagedGrantMock {\\r\\n    address public grantee;\\r\\n\\r\\n    //slither-disable-next-line missing-zero-check\\r\\n    function setGrantee(address _grantee) external {\\r\\n        grantee = _grantee;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract ExtendedTokenStaking is TokenStaking {\\r\\n    constructor(\\r\\n        T _token,\\r\\n        IKeepTokenStaking _keepStakingContract,\\r\\n        INuCypherStakingEscrow _nucypherStakingContract,\\r\\n        VendingMachine _keepVendingMachine,\\r\\n        VendingMachine _nucypherVendingMachine,\\r\\n        KeepStake _keepStake\\r\\n    )\\r\\n        TokenStaking(\\r\\n            _token,\\r\\n            _keepStakingContract,\\r\\n            _nucypherStakingContract,\\r\\n            _keepVendingMachine,\\r\\n            _nucypherVendingMachine,\\r\\n            _keepStake\\r\\n        )\\r\\n    {}\\r\\n\\r\\n    function cleanAuthorizedApplications(\\r\\n        address stakingProvider,\\r\\n        uint256 numberToDelete\\r\\n    ) external {\\r\\n        StakingProviderInfo storage stakingProviderStruct = stakingProviders[\\r\\n            stakingProvider\\r\\n        ];\\r\\n        cleanAuthorizedApplications(stakingProviderStruct, numberToDelete);\\r\\n    }\\r\\n\\r\\n    function setAuthorization(\\r\\n        address stakingProvider,\\r\\n        address application,\\r\\n        uint96 amount\\r\\n    ) external {\\r\\n        stakingProviders[stakingProvider]\\r\\n            .authorizations[application]\\r\\n            .authorized = amount;\\r\\n    }\\r\\n\\r\\n    function setAuthorizedApplications(\\r\\n        address stakingProvider,\\r\\n        address[] memory _applications\\r\\n    ) external {\\r\\n        stakingProviders[stakingProvider]\\r\\n            .authorizedApplications = _applications;\\r\\n    }\\r\\n\\r\\n    // to decrease size of test contract\\r\\n    function processSlashing(uint256 count) external override {}\\r\\n\\r\\n    function getAuthorizedApplications(address stakingProvider)\\r\\n        external\\r\\n        view\\r\\n        returns (address[] memory)\\r\\n    {\\r\\n        return stakingProviders[stakingProvider].authorizedApplications;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x63e346aafc3459c0b8341603203eef43eca56a8f1bd09a9d123eba037edaa349\",\"license\":\"GPL-3.0-or-later\"},\"contracts/token/T.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n\\r\\npragma solidity 0.8.9;\\r\\n\\r\\nimport \\\"../governance/Checkpoints.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\r\\nimport \\\"@thesis/solidity-contracts/contracts/token/ERC20WithPermit.sol\\\";\\r\\nimport \\\"@thesis/solidity-contracts/contracts/token/MisfundRecovery.sol\\\";\\r\\n\\r\\n/// @title T token\\r\\n/// @notice Threshold Network T token\\r\\n/// @dev By default, token balance does not account for voting power.\\r\\n///      This makes transfers cheaper. The downside is that it requires users\\r\\n///      to delegate to themselves to activate checkpoints and have their\\r\\n///      voting power tracked.\\r\\ncontract T is ERC20WithPermit, MisfundRecovery, Checkpoints {\\r\\n    /// @notice The EIP-712 typehash for the delegation struct used by\\r\\n    ///         `delegateBySig`.\\r\\n    bytes32 public constant DELEGATION_TYPEHASH =\\r\\n        keccak256(\\r\\n            \\\"Delegation(address delegatee,uint256 nonce,uint256 deadline)\\\"\\r\\n        );\\r\\n\\r\\n    constructor() ERC20WithPermit(\\\"Threshold Network Token\\\", \\\"T\\\") {}\\r\\n\\r\\n    /// @notice Delegates votes from signatory to `delegatee`\\r\\n    /// @param delegatee The address to delegate votes to\\r\\n    /// @param deadline The time at which to expire the signature\\r\\n    /// @param v The recovery byte of the signature\\r\\n    /// @param r Half of the ECDSA signature pair\\r\\n    /// @param s Half of the ECDSA signature pair\\r\\n    function delegateBySig(\\r\\n        address signatory,\\r\\n        address delegatee,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external {\\r\\n        /* solhint-disable-next-line not-rely-on-time */\\r\\n        require(deadline >= block.timestamp, \\\"Delegation expired\\\");\\r\\n\\r\\n        // Validate `s` and `v` values for a malleability concern described in EIP2.\\r\\n        // Only signatures with `s` value in the lower half of the secp256k1\\r\\n        // curve's order and `v` value of 27 or 28 are considered valid.\\r\\n        require(\\r\\n            uint256(s) <=\\r\\n                0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\\r\\n            \\\"Invalid signature 's' value\\\"\\r\\n        );\\r\\n        require(v == 27 || v == 28, \\\"Invalid signature 'v' value\\\");\\r\\n\\r\\n        bytes32 digest = keccak256(\\r\\n            abi.encodePacked(\\r\\n                \\\"\\\\x19\\\\x01\\\",\\r\\n                DOMAIN_SEPARATOR(),\\r\\n                keccak256(\\r\\n                    abi.encode(\\r\\n                        DELEGATION_TYPEHASH,\\r\\n                        delegatee,\\r\\n                        nonce[signatory]++,\\r\\n                        deadline\\r\\n                    )\\r\\n                )\\r\\n            )\\r\\n        );\\r\\n\\r\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\r\\n        require(\\r\\n            recoveredAddress != address(0) && recoveredAddress == signatory,\\r\\n            \\\"Invalid signature\\\"\\r\\n        );\\r\\n\\r\\n        return delegate(signatory, delegatee);\\r\\n    }\\r\\n\\r\\n    /// @notice Delegate votes from `msg.sender` to `delegatee`.\\r\\n    /// @param delegatee The address to delegate votes to\\r\\n    function delegate(address delegatee) public virtual {\\r\\n        return delegate(msg.sender, delegatee);\\r\\n    }\\r\\n\\r\\n    // slither-disable-next-line dead-code\\r\\n    function beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal override {\\r\\n        uint96 safeAmount = SafeCast.toUint96(amount);\\r\\n\\r\\n        // When minting:\\r\\n        if (from == address(0)) {\\r\\n            // Does not allow to mint more than uint96 can fit. Otherwise, the\\r\\n            // Checkpoint might not fit the balance.\\r\\n            require(\\r\\n                totalSupply + amount <= maxSupply(),\\r\\n                \\\"Maximum total supply exceeded\\\"\\r\\n            );\\r\\n            writeCheckpoint(_totalSupplyCheckpoints, add, safeAmount);\\r\\n        }\\r\\n\\r\\n        // When burning:\\r\\n        if (to == address(0)) {\\r\\n            writeCheckpoint(_totalSupplyCheckpoints, subtract, safeAmount);\\r\\n        }\\r\\n\\r\\n        moveVotingPower(delegates(from), delegates(to), safeAmount);\\r\\n    }\\r\\n\\r\\n    function delegate(address delegator, address delegatee)\\r\\n        internal\\r\\n        virtual\\r\\n        override\\r\\n    {\\r\\n        address currentDelegate = delegates(delegator);\\r\\n        uint96 delegatorBalance = SafeCast.toUint96(balanceOf[delegator]);\\r\\n        _delegates[delegator] = delegatee;\\r\\n\\r\\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\\r\\n\\r\\n        moveVotingPower(currentDelegate, delegatee, delegatorBalance);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xfab0f3951f4d44ed33c1ef5fc2d4806bbc1245d9ccb559e2f90220ea94c30548\",\"license\":\"GPL-3.0-or-later\"},\"contracts/utils/PercentUtils.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n\\r\\npragma solidity 0.8.9;\\r\\n\\r\\nlibrary PercentUtils {\\r\\n    // Return `b`% of `a`\\r\\n    // 200.percent(40) == 80\\r\\n    // Commutative, works both ways\\r\\n    function percent(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return (a * b) / 100;\\r\\n    }\\r\\n\\r\\n    // Return `a` as percentage of `b`:\\r\\n    // 80.asPercentOf(200) == 40\\r\\n    //slither-disable-next-line dead-code\\r\\n    function asPercentOf(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return (a * 100) / b;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x73fa6d52600d278b712257e75cef8d3252e7cf09503f93b889a0d012acc728f0\",\"license\":\"GPL-3.0-or-later\"},\"contracts/utils/SafeTUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n\\r\\npragma solidity 0.8.9;\\r\\n\\r\\nimport \\\"../token/T.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\r\\n\\r\\n/// @notice A wrapper around OpenZeppelin's `SafeERC20Upgradeable` but specific\\r\\n///         to the T token. Use this library in upgradeable contracts. If your\\r\\n///         contract is non-upgradeable, then the traditional `SafeERC20` works.\\r\\n///         The motivation is to prevent upgradeable contracts that use T from\\r\\n///         depending on the `Address` library, which can be problematic since\\r\\n///         it uses `delegatecall`, which is discouraged by OpenZeppelin for use\\r\\n///         in upgradeable contracts.\\r\\n/// @dev This implementation force-casts T to `IERC20Upgradeable` to make it\\r\\n///      work with `SafeERC20Upgradeable`.\\r\\nlibrary SafeTUpgradeable {\\r\\n    function safeTransfer(\\r\\n        T token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        SafeERC20Upgradeable.safeTransfer(\\r\\n            IERC20Upgradeable(address(token)),\\r\\n            to,\\r\\n            value\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        T token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        SafeERC20Upgradeable.safeTransferFrom(\\r\\n            IERC20Upgradeable(address(token)),\\r\\n            from,\\r\\n            to,\\r\\n            value\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xb08d9c245a53fedeb738e045baa32f71a86ce3aa73cb8186a7d0e4ead988c3a1\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vending/VendingMachine.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n// \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n//               \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c    \\u2590\\u2588\\u2588\\u2588\\u2588\\u258c\\r\\n\\r\\npragma solidity 0.8.9;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\r\\n\\r\\nimport \\\"@thesis/solidity-contracts/contracts/token/IReceiveApproval.sol\\\";\\r\\nimport \\\"../token/T.sol\\\";\\r\\n\\r\\n/// @title T token vending machine\\r\\n/// @notice Contract implements a special update protocol to enable KEEP/NU\\r\\n///         token holders to wrap their tokens and obtain T tokens according\\r\\n///         to a fixed ratio. This will go on indefinitely and enable NU and\\r\\n///         KEEP token holders to join T network without needing to buy or\\r\\n///         sell any assets. Logistically, anyone holding NU or KEEP can wrap\\r\\n///         those assets in order to upgrade to T. They can also unwrap T in\\r\\n///         order to downgrade back to the underlying asset. There is a separate\\r\\n///         instance of this contract deployed for KEEP holders and a separate\\r\\n///         instance of this contract deployed for NU holders.\\r\\ncontract VendingMachine is IReceiveApproval {\\r\\n    using SafeERC20 for IERC20;\\r\\n    using SafeERC20 for T;\\r\\n\\r\\n    /// @notice Number of decimal places of precision in conversion to/from\\r\\n    ///         wrapped tokens (assuming typical ERC20 token with 18 decimals).\\r\\n    ///         This implies that amounts of wrapped tokens below this precision\\r\\n    ///         won't take part in the conversion. E.g., for a value of 3, then\\r\\n    ///         for a conversion of 1.123456789 wrapped tokens, only 1.123 is\\r\\n    ///         convertible (i.e., 3 decimal places), and 0.000456789 is left.\\r\\n    uint256 public constant WRAPPED_TOKEN_CONVERSION_PRECISION = 3;\\r\\n\\r\\n    /// @notice Divisor for precision purposes, used to represent fractions.\\r\\n    uint256 public constant FLOATING_POINT_DIVISOR =\\r\\n        10**(18 - WRAPPED_TOKEN_CONVERSION_PRECISION);\\r\\n\\r\\n    /// @notice The token being wrapped to T (KEEP/NU).\\r\\n    IERC20 public immutable wrappedToken;\\r\\n\\r\\n    /// @notice T token contract.\\r\\n    T public immutable tToken;\\r\\n\\r\\n    /// @notice The ratio with which T token is converted based on the provided\\r\\n    ///         token being wrapped (KEEP/NU), expressed in 1e18 precision.\\r\\n    ///\\r\\n    ///         When wrapping:\\r\\n    ///           x [T] = amount [KEEP/NU] * ratio / FLOATING_POINT_DIVISOR\\r\\n    ///\\r\\n    ///         When unwrapping:\\r\\n    ///           x [KEEP/NU] = amount [T] * FLOATING_POINT_DIVISOR / ratio\\r\\n    uint256 public immutable ratio;\\r\\n\\r\\n    /// @notice The total balance of wrapped tokens for the given holder\\r\\n    ///         account. Only holders that have previously wrapped KEEP/NU to T\\r\\n    ///         can unwrap, up to the amount previously wrapped.\\r\\n    mapping(address => uint256) public wrappedBalance;\\r\\n\\r\\n    event Wrapped(\\r\\n        address indexed recipient,\\r\\n        uint256 wrappedTokenAmount,\\r\\n        uint256 tTokenAmount\\r\\n    );\\r\\n    event Unwrapped(\\r\\n        address indexed recipient,\\r\\n        uint256 tTokenAmount,\\r\\n        uint256 wrappedTokenAmount\\r\\n    );\\r\\n\\r\\n    /// @notice Sets the reference to `wrappedToken` and `tToken`. Initializes\\r\\n    ///         conversion `ratio` between wrapped token and T based on the\\r\\n    ///         provided `_tTokenAllocation` and `_wrappedTokenAllocation`.\\r\\n    /// @param _wrappedToken Address to ERC20 token that will be wrapped to T\\r\\n    /// @param _tToken Address of T token\\r\\n    /// @param _wrappedTokenAllocation The total supply of the token that will be\\r\\n    ///       wrapped to T\\r\\n    /// @param _tTokenAllocation The allocation of T this instance of Vending\\r\\n    ///        Machine will receive\\r\\n    /// @dev Multiplications in this contract can't overflow uint256 as we\\r\\n    ///     restrict `_wrappedTokenAllocation` and `_tTokenAllocation` to\\r\\n    ///     96 bits and FLOATING_POINT_DIVISOR fits in less than 60 bits.\\r\\n    constructor(\\r\\n        IERC20 _wrappedToken,\\r\\n        T _tToken,\\r\\n        uint96 _wrappedTokenAllocation,\\r\\n        uint96 _tTokenAllocation\\r\\n    ) {\\r\\n        wrappedToken = _wrappedToken;\\r\\n        tToken = _tToken;\\r\\n        ratio =\\r\\n            (FLOATING_POINT_DIVISOR * _tTokenAllocation) /\\r\\n            _wrappedTokenAllocation;\\r\\n    }\\r\\n\\r\\n    /// @notice Wraps up to the the given `amount` of the token (KEEP/NU) and\\r\\n    ///         releases T token proportionally to the amount being wrapped with\\r\\n    ///         respect to the wrap ratio. The token holder needs to have at\\r\\n    ///         least the given amount of the wrapped token (KEEP/NU) approved\\r\\n    ///         to transfer to the Vending Machine before calling this function.\\r\\n    /// @param amount The amount of KEEP/NU to be wrapped\\r\\n    function wrap(uint256 amount) external {\\r\\n        _wrap(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    /// @notice Wraps up to the given amount of the token (KEEP/NU) and releases\\r\\n    ///         T token proportionally to the amount being wrapped with respect\\r\\n    ///         to the wrap ratio. This is a shortcut to `wrap` function that\\r\\n    ///         avoids a separate approval transaction. Only KEEP/NU token\\r\\n    ///         is allowed as a caller, so please call this function via\\r\\n    ///         token's `approveAndCall`.\\r\\n    /// @param from Caller's address, must be the same as `wrappedToken` field\\r\\n    /// @param amount The amount of KEEP/NU to be wrapped\\r\\n    /// @param token Token's address, must be the same as `wrappedToken` field\\r\\n    function receiveApproval(\\r\\n        address from,\\r\\n        uint256 amount,\\r\\n        address token,\\r\\n        bytes calldata\\r\\n    ) external override {\\r\\n        require(\\r\\n            token == address(wrappedToken),\\r\\n            \\\"Token is not the wrapped token\\\"\\r\\n        );\\r\\n        require(\\r\\n            msg.sender == address(wrappedToken),\\r\\n            \\\"Only wrapped token caller allowed\\\"\\r\\n        );\\r\\n        _wrap(from, amount);\\r\\n    }\\r\\n\\r\\n    /// @notice Unwraps up to the given `amount` of T back to the legacy token\\r\\n    ///         (KEEP/NU) according to the wrap ratio. It can only be called by\\r\\n    ///         a token holder who previously wrapped their tokens in this\\r\\n    ///         vending machine contract. The token holder can't unwrap more\\r\\n    ///         tokens than they originally wrapped. The token holder needs to\\r\\n    ///         have at least the given amount of T tokens approved to transfer\\r\\n    ///         to the Vending Machine before calling this function.\\r\\n    /// @param amount The amount of T to unwrap back to the collateral (KEEP/NU)\\r\\n    function unwrap(uint256 amount) external {\\r\\n        _unwrap(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the T token amount that's obtained from `amount` wrapped\\r\\n    ///         tokens (KEEP/NU), and the remainder that can't be upgraded.\\r\\n    function conversionToT(uint256 amount)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256 tAmount, uint256 wrappedRemainder)\\r\\n    {\\r\\n        wrappedRemainder = amount % FLOATING_POINT_DIVISOR;\\r\\n        uint256 convertibleAmount = amount - wrappedRemainder;\\r\\n        tAmount = (convertibleAmount * ratio) / FLOATING_POINT_DIVISOR;\\r\\n    }\\r\\n\\r\\n    /// @notice The amount of wrapped tokens (KEEP/NU) that's obtained from\\r\\n    ///         `amount` T tokens, and the remainder that can't be downgraded.\\r\\n    function conversionFromT(uint256 amount)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256 wrappedAmount, uint256 tRemainder)\\r\\n    {\\r\\n        tRemainder = amount % ratio;\\r\\n        uint256 convertibleAmount = amount - tRemainder;\\r\\n        wrappedAmount = (convertibleAmount * FLOATING_POINT_DIVISOR) / ratio;\\r\\n    }\\r\\n\\r\\n    function _wrap(address tokenHolder, uint256 wrappedTokenAmount) internal {\\r\\n        (uint256 tTokenAmount, uint256 remainder) = conversionToT(\\r\\n            wrappedTokenAmount\\r\\n        );\\r\\n        wrappedTokenAmount -= remainder;\\r\\n        require(wrappedTokenAmount > 0, \\\"Disallow conversions of zero value\\\");\\r\\n        emit Wrapped(tokenHolder, wrappedTokenAmount, tTokenAmount);\\r\\n\\r\\n        wrappedBalance[tokenHolder] += wrappedTokenAmount;\\r\\n        wrappedToken.safeTransferFrom(\\r\\n            tokenHolder,\\r\\n            address(this),\\r\\n            wrappedTokenAmount\\r\\n        );\\r\\n        tToken.safeTransfer(tokenHolder, tTokenAmount);\\r\\n    }\\r\\n\\r\\n    function _unwrap(address tokenHolder, uint256 tTokenAmount) internal {\\r\\n        (uint256 wrappedTokenAmount, uint256 remainder) = conversionFromT(\\r\\n            tTokenAmount\\r\\n        );\\r\\n        tTokenAmount -= remainder;\\r\\n        require(tTokenAmount > 0, \\\"Disallow conversions of zero value\\\");\\r\\n        require(\\r\\n            wrappedBalance[tokenHolder] >= wrappedTokenAmount,\\r\\n            \\\"Can not unwrap more than previously wrapped\\\"\\r\\n        );\\r\\n\\r\\n        emit Unwrapped(tokenHolder, tTokenAmount, wrappedTokenAmount);\\r\\n        wrappedBalance[tokenHolder] -= wrappedTokenAmount;\\r\\n        tToken.safeTransferFrom(tokenHolder, address(this), tTokenAmount);\\r\\n        wrappedToken.safeTransfer(tokenHolder, wrappedTokenAmount);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x6eba12471187b644b11157327ea11fe275af6276dc06876511bd70bb31c9fdef\",\"license\":\"GPL-3.0-or-later\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506104f7806100206000396000f3fe608060405234801561001057600080fd5b506004361061006d5760003560e01c8063178b6de6146100725780633223ff4b146100ae5780633d4fa8e5146100c15780634e745f1f146100ed5780637da5f6a6146101655780639168ae721461018557806399cc218c146101d2575b600080fd5b61009b6100803660046103b9565b6001600160a01b031660009081526020819052604090205490565b6040519081526020015b60405180910390f35b61009b6100bc3660046103db565b6101e5565b6100eb6100cf36600461040e565b6001600160a01b03909116600090815260208190526040902055565b005b6101416100fb3660046103b9565b604080518082018252600080825260209182018190526001600160a01b039384168152808252829020825180840190935280548352600101549092169181019190915290565b60408051825181526020928301516001600160a01b031692810192909252016100a5565b61009b6101733660046103b9565b60016020526000908152604090205481565b6101b56101933660046103b9565b600060208190529081526040902080546001909101546001600160a01b031682565b604080519283526001600160a01b039091166020830152016100a5565b6100eb6101e0366004610438565b6102db565b6001600160a01b038083166000908152602081905260408120600181015491929091161580610223575060018101546001600160a01b038481169116145b61028d5760405162461bcd60e51b815260206004820152603060248201527f416e6f746865722070726f76696465722077617320616c72656164792073657460448201526f103337b9103a3434b99039ba30b5b2b960811b60648201526084015b60405180910390fd5b60018101546001600160a01b03166102bd576001810180546001600160a01b0319166001600160a01b0385161790555b5050506001600160a01b031660009081526020819052604090205490565b6000831161033d5760405162461bcd60e51b815260206004820152602960248201527f416d6f756e7420746f20736c617368206d7573742062652067726561746572206044820152687468616e207a65726f60b81b6064820152608401610284565b6001600160a01b03841660009081526020819052604081208054859290610365908490610492565b90915550506001600160a01b038216600090815260016020526040812080548392906103929084906104a9565b909155505050505050565b80356001600160a01b03811681146103b457600080fd5b919050565b6000602082840312156103cb57600080fd5b6103d48261039d565b9392505050565b600080604083850312156103ee57600080fd5b6103f78361039d565b91506104056020840161039d565b90509250929050565b6000806040838503121561042157600080fd5b61042a8361039d565b946020939093013593505050565b6000806000806080858703121561044e57600080fd5b6104578561039d565b93506020850135925061046c6040860161039d565b9396929550929360600135925050565b634e487b7160e01b600052601160045260246000fd5b6000828210156104a4576104a461047c565b500390565b600082198211156104bc576104bc61047c565b50019056fea2646970667358221220b79a2f8e42bb939e0b59811c963cc2d5dac4763c1b610c581d9c1a3285ede2e764736f6c63430008090033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061006d5760003560e01c8063178b6de6146100725780633223ff4b146100ae5780633d4fa8e5146100c15780634e745f1f146100ed5780637da5f6a6146101655780639168ae721461018557806399cc218c146101d2575b600080fd5b61009b6100803660046103b9565b6001600160a01b031660009081526020819052604090205490565b6040519081526020015b60405180910390f35b61009b6100bc3660046103db565b6101e5565b6100eb6100cf36600461040e565b6001600160a01b03909116600090815260208190526040902055565b005b6101416100fb3660046103b9565b604080518082018252600080825260209182018190526001600160a01b039384168152808252829020825180840190935280548352600101549092169181019190915290565b60408051825181526020928301516001600160a01b031692810192909252016100a5565b61009b6101733660046103b9565b60016020526000908152604090205481565b6101b56101933660046103b9565b600060208190529081526040902080546001909101546001600160a01b031682565b604080519283526001600160a01b039091166020830152016100a5565b6100eb6101e0366004610438565b6102db565b6001600160a01b038083166000908152602081905260408120600181015491929091161580610223575060018101546001600160a01b038481169116145b61028d5760405162461bcd60e51b815260206004820152603060248201527f416e6f746865722070726f76696465722077617320616c72656164792073657460448201526f103337b9103a3434b99039ba30b5b2b960811b60648201526084015b60405180910390fd5b60018101546001600160a01b03166102bd576001810180546001600160a01b0319166001600160a01b0385161790555b5050506001600160a01b031660009081526020819052604090205490565b6000831161033d5760405162461bcd60e51b815260206004820152602960248201527f416d6f756e7420746f20736c617368206d7573742062652067726561746572206044820152687468616e207a65726f60b81b6064820152608401610284565b6001600160a01b03841660009081526020819052604081208054859290610365908490610492565b90915550506001600160a01b038216600090815260016020526040812080548392906103929084906104a9565b909155505050505050565b80356001600160a01b03811681146103b457600080fd5b919050565b6000602082840312156103cb57600080fd5b6103d48261039d565b9392505050565b600080604083850312156103ee57600080fd5b6103f78361039d565b91506104056020840161039d565b90509250929050565b6000806040838503121561042157600080fd5b61042a8361039d565b946020939093013593505050565b6000806000806080858703121561044e57600080fd5b6104578561039d565b93506020850135925061046c6040860161039d565b9396929550929360600135925050565b634e487b7160e01b600052601160045260246000fd5b6000828210156104a4576104a461047c565b500390565b600082198211156104bc576104bc61047c565b50019056fea2646970667358221220b79a2f8e42bb939e0b59811c963cc2d5dac4763c1b610c581d9c1a3285ede2e764736f6c63430008090033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "slashStaker(address,uint256,address,uint256)": {
        "params": {
          "investigator": "Investigator",
          "penalty": "Penalty",
          "reward": "Reward for the investigator",
          "staker": "Staker's address"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getAllTokens(address)": {
        "notice": "Get all tokens belonging to the staker"
      },
      "requestMerge(address,address)": {
        "notice": "Request merge between NuCypher staking contract and T staking contract.         Returns amount of staked tokens"
      },
      "slashStaker(address,uint256,address,uint256)": {
        "notice": "Slash the staker's stake and reward the investigator"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 17639,
        "contract": "contracts/test/TokenStakingTestSet.sol:NuCypherTokenStakingMock",
        "label": "stakers",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_struct(StakerStruct)17634_storage)"
      },
      {
        "astId": 17643,
        "contract": "contracts/test/TokenStakingTestSet.sol:NuCypherTokenStakingMock",
        "label": "investigators",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_uint256)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_struct(StakerStruct)17634_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct NuCypherTokenStakingMock.StakerStruct)",
        "numberOfBytes": "32",
        "value": "t_struct(StakerStruct)17634_storage"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_struct(StakerStruct)17634_storage": {
        "encoding": "inplace",
        "label": "struct NuCypherTokenStakingMock.StakerStruct",
        "members": [
          {
            "astId": 17631,
            "contract": "contracts/test/TokenStakingTestSet.sol:NuCypherTokenStakingMock",
            "label": "value",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 17633,
            "contract": "contracts/test/TokenStakingTestSet.sol:NuCypherTokenStakingMock",
            "label": "stakingProvider",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}