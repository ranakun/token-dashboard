{
  "address": "0xd9719BF6D8aF363CAD315fC1DD4Ee2b5b303fa25",
  "abi": [
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct AltBn128.gfP2",
              "name": "x",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct AltBn128.gfP2",
              "name": "y",
              "type": "tuple"
            }
          ],
          "internalType": "struct AltBn128.G2Point",
          "name": "publicKey",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "x",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "y",
              "type": "uint256"
            }
          ],
          "internalType": "struct AltBn128.G1Point",
          "name": "message",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "x",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "y",
              "type": "uint256"
            }
          ],
          "internalType": "struct AltBn128.G1Point",
          "name": "signature",
          "type": "tuple"
        }
      ],
      "name": "_verify",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "message",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "secretKey",
          "type": "uint256"
        }
      ],
      "name": "sign",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "publicKey",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "message",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "verify",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "publicKey",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "message",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "verifyBytes",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xc4712ebe2b1250ca4363856ac0e64e9465acd86b2e27392417d8cca211d6a19d",
  "receipt": {
    "to": null,
    "from": "0x819871C3Af9d26AaA3d8D17B2A79D1E313c56735",
    "contractAddress": "0xd9719BF6D8aF363CAD315fC1DD4Ee2b5b303fa25",
    "transactionIndex": 35,
    "gasUsed": "709678",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xbbd3b7f2af04acfa8aac78217eb750251d24c0cf08bfa650d230a7a9d9c37dab",
    "transactionHash": "0xc4712ebe2b1250ca4363856ac0e64e9465acd86b2e27392417d8cca211d6a19d",
    "logs": [],
    "blockNumber": 8635797,
    "cumulativeGasUsed": "5110782",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "4294a4f250f19b5b3592a23e3aa97a5c",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct AltBn128.gfP2\",\"name\":\"x\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct AltBn128.gfP2\",\"name\":\"y\",\"type\":\"tuple\"}],\"internalType\":\"struct AltBn128.G2Point\",\"name\":\"publicKey\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct AltBn128.G1Point\",\"name\":\"message\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct AltBn128.G1Point\",\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"_verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"secretKey\",\"type\":\"uint256\"}],\"name\":\"sign\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"publicKey\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"publicKey\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"verifyBytes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Library for verification of 2-pairing-check BLS signatures, including      basic, aggregated, or reconstructed threshold BLS signatures, generated      using the AltBn128 curve.\",\"kind\":\"dev\",\"methods\":{\"sign(bytes,uint256)\":{\"details\":\"Creates a signature over message using the provided secret key.\"},\"verify(bytes,bytes,bytes)\":{\"details\":\"Verify performs the pairing operation to check if the signature      is correct for the provided message and the corresponding public      key. Public key must be a valid point on G2 curve in an      uncompressed format. Message must be a valid point on G1 curve in      an uncompressed format. Signature must be a valid point on G1      curve in an uncompressed format.\"},\"verifyBytes(bytes,bytes,bytes)\":{\"details\":\"Wraps the functionality of BLS.verify, but hashes a message to      a point on G1 and marshal to bytes first to allow raw bytes      verification.\"}},\"title\":\"BLS signatures verification\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/libraries/BLS.sol\":\"BLS\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/libraries/AltBn128.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\r\\n//\\r\\n// \\u2593\\u2593\\u258c \\u2593\\u2593 \\u2590\\u2593\\u2593 \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u258c\\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2584\\r\\n// \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u258c\\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\r\\n//   \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593    \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2580    \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593    \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593   \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593     \\u2593\\u2593\\u2593\\u2593\\u2593   \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u258c   \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\r\\n//   \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2584\\u2584\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2580      \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2584\\u2584\\u2584\\u2584         \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2584\\u2584\\u2584\\u2584         \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u258c   \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\r\\n//   \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2580        \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593         \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593         \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\r\\n//   \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2580\\u2580\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2584       \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2580\\u2580\\u2580\\u2580         \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2580\\u2580\\u2580\\u2580         \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2580\\r\\n//   \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593   \\u2580\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2584     \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593     \\u2593\\u2593\\u2593\\u2593\\u2593   \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593     \\u2593\\u2593\\u2593\\u2593\\u2593   \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u258c\\r\\n// \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593  \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\r\\n// \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593  \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\r\\n//\\r\\n//\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./ModUtils.sol\\\";\\r\\n\\r\\n/// @title Operations on alt_bn128\\r\\n/// @dev Implementations of common elliptic curve operations on Ethereum's\\r\\n///      (poorly named) alt_bn128 curve. Whenever possible, use post-Byzantium\\r\\n///      pre-compiled contracts to offset gas costs. Note that these\\r\\n///      pre-compiles might not be available on all (eg private) chains.\\r\\nlibrary AltBn128 {\\r\\n    using ModUtils for uint256;\\r\\n\\r\\n    // G1Point implements a point in G1 group.\\r\\n    struct G1Point {\\r\\n        uint256 x;\\r\\n        uint256 y;\\r\\n    }\\r\\n\\r\\n    // gfP2 implements a field of size p\\u00b2 as a quadratic extension of the base\\r\\n    // field.\\r\\n    struct gfP2 {\\r\\n        uint256 x;\\r\\n        uint256 y;\\r\\n    }\\r\\n\\r\\n    // G2Point implements a point in G2 group.\\r\\n    struct G2Point {\\r\\n        gfP2 x;\\r\\n        gfP2 y;\\r\\n    }\\r\\n\\r\\n    // p is a prime over which we form a basic field\\r\\n    // Taken from go-ethereum/crypto/bn256/cloudflare/constants.go\\r\\n    uint256 internal constant p =\\r\\n        21888242871839275222246405745257275088696311157297823662689037894645226208583;\\r\\n\\r\\n    /// @dev Gets generator of G1 group.\\r\\n    ///      Taken from go-ethereum/crypto/bn256/cloudflare/curve.go\\r\\n    uint256 internal constant g1x = 1;\\r\\n    uint256 internal constant g1y = 2;\\r\\n\\r\\n    /// @dev Gets generator of G2 group.\\r\\n    ///      Taken from go-ethereum/crypto/bn256/cloudflare/twist.go\\r\\n    uint256 internal constant g2xx =\\r\\n        11559732032986387107991004021392285783925812861821192530917403151452391805634;\\r\\n    uint256 internal constant g2xy =\\r\\n        10857046999023057135944570762232829481370756359578518086990519993285655852781;\\r\\n    uint256 internal constant g2yx =\\r\\n        4082367875863433681332203403145435568316851327593401208105741076214120093531;\\r\\n    uint256 internal constant g2yy =\\r\\n        8495653923123431417604973247489272438418190587263600148770280649306958101930;\\r\\n\\r\\n    /// @dev Gets twist curve B constant.\\r\\n    ///      Taken from go-ethereum/crypto/bn256/cloudflare/twist.go\\r\\n    uint256 internal constant twistBx =\\r\\n        266929791119991161246907387137283842545076965332900288569378510910307636690;\\r\\n    uint256 internal constant twistBy =\\r\\n        19485874751759354771024239261021720505790618469301721065564631296452457478373;\\r\\n\\r\\n    /// @dev Gets root of the point where x and y are equal.\\r\\n    uint256 internal constant hexRootX =\\r\\n        21573744529824266246521972077326577680729363968861965890554801909984373949499;\\r\\n    uint256 internal constant hexRootY =\\r\\n        16854739155576650954933913186877292401521110422362946064090026408937773542853;\\r\\n\\r\\n    /// @dev g1YFromX computes a Y value for a G1 point based on an X value.\\r\\n    ///      This computation is simply evaluating the curve equation for Y on a\\r\\n    ///      given X, and allows a point on the curve to be represented by just\\r\\n    ///      an X value + a sign bit.\\r\\n    function g1YFromX(uint256 x) internal view returns (uint256) {\\r\\n        return ((x.modExp(3, p) + 3) % p).modSqrt(p);\\r\\n    }\\r\\n\\r\\n    /// @dev Hash a byte array message, m, and map it deterministically to a\\r\\n    ///      point on G1. Note that this approach was chosen for its simplicity\\r\\n    ///      and lower gas cost on the EVM, rather than good distribution of\\r\\n    ///      points on G1.\\r\\n    function g1HashToPoint(bytes memory m)\\r\\n        internal\\r\\n        view\\r\\n        returns (G1Point memory)\\r\\n    {\\r\\n        unchecked {\\r\\n            bytes32 h = sha256(m);\\r\\n            uint256 x = uint256(h) % p;\\r\\n            uint256 y;\\r\\n\\r\\n            while (true) {\\r\\n                y = g1YFromX(x);\\r\\n                if (y > 0) {\\r\\n                    return G1Point(x, y);\\r\\n                }\\r\\n                x += 1;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Decompress a point on G1 from a single uint256.\\r\\n    function g1Decompress(bytes32 m) internal view returns (G1Point memory) {\\r\\n        unchecked {\\r\\n            bytes32 mX = bytes32(0);\\r\\n            bytes1 leadX = m[0] & 0x7f;\\r\\n            // slither-disable-next-line incorrect-shift\\r\\n            uint256 mask = 0xff << (31 * 8);\\r\\n            mX = (m & ~bytes32(mask)) | (leadX >> 0);\\r\\n\\r\\n            uint256 x = uint256(mX);\\r\\n            uint256 y = g1YFromX(x);\\r\\n\\r\\n            if (parity(y) != (m[0] & 0x80) >> 7) {\\r\\n                y = p - y;\\r\\n            }\\r\\n\\r\\n            require(\\r\\n                isG1PointOnCurve(G1Point(x, y)),\\r\\n                \\\"Malformed bn256.G1 point.\\\"\\r\\n            );\\r\\n\\r\\n            return G1Point(x, y);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Wraps the point addition pre-compile introduced in Byzantium.\\r\\n    ///      Returns the sum of two points on G1. Revert if the provided points\\r\\n    ///      are not on the curve.\\r\\n    function g1Add(G1Point memory a, G1Point memory b)\\r\\n        internal\\r\\n        view\\r\\n        returns (G1Point memory c)\\r\\n    {\\r\\n        assembly {\\r\\n            let arg := mload(0x40)\\r\\n            mstore(arg, mload(a))\\r\\n            mstore(add(arg, 0x20), mload(add(a, 0x20)))\\r\\n            mstore(add(arg, 0x40), mload(b))\\r\\n            mstore(add(arg, 0x60), mload(add(b, 0x20)))\\r\\n            // 0x60 is the ECADD precompile address\\r\\n            if iszero(staticcall(not(0), 0x06, arg, 0x80, c, 0x40)) {\\r\\n                revert(0, 0)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns true if G1 point is on the curve.\\r\\n    function isG1PointOnCurve(G1Point memory point)\\r\\n        internal\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return point.y.modExp(2, p) == (point.x.modExp(3, p) + 3) % p;\\r\\n    }\\r\\n\\r\\n    /// @dev Wraps the scalar point multiplication pre-compile introduced in\\r\\n    ///      Byzantium. The result of a point from G1 multiplied by a scalar\\r\\n    ///      should match the point added to itself the same number of times.\\r\\n    ///      Revert if the provided point isn't on the curve.\\r\\n    function scalarMultiply(G1Point memory p_1, uint256 scalar)\\r\\n        internal\\r\\n        view\\r\\n        returns (G1Point memory p_2)\\r\\n    {\\r\\n        assembly {\\r\\n            let arg := mload(0x40)\\r\\n            mstore(arg, mload(p_1))\\r\\n            mstore(add(arg, 0x20), mload(add(p_1, 0x20)))\\r\\n            mstore(add(arg, 0x40), scalar)\\r\\n            // 0x07 is the ECMUL precompile address\\r\\n            if iszero(staticcall(not(0), 0x07, arg, 0x60, p_2, 0x40)) {\\r\\n                revert(0, 0)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Wraps the pairing check pre-compile introduced in Byzantium.\\r\\n    ///      Returns the result of a pairing check of 2 pairs\\r\\n    ///      (G1 p1, G2 p2) (G1 p3, G2 p4)\\r\\n    function pairing(\\r\\n        G1Point memory p1,\\r\\n        G2Point memory p2,\\r\\n        G1Point memory p3,\\r\\n        G2Point memory p4\\r\\n    ) internal view returns (bool result) {\\r\\n        uint256 _c;\\r\\n        assembly {\\r\\n            let c := mload(0x40)\\r\\n            let arg := add(c, 0x20)\\r\\n\\r\\n            mstore(arg, mload(p1))\\r\\n            mstore(add(arg, 0x20), mload(add(p1, 0x20)))\\r\\n\\r\\n            let p2x := mload(p2)\\r\\n            mstore(add(arg, 0x40), mload(p2x))\\r\\n            mstore(add(arg, 0x60), mload(add(p2x, 0x20)))\\r\\n\\r\\n            let p2y := mload(add(p2, 0x20))\\r\\n            mstore(add(arg, 0x80), mload(p2y))\\r\\n            mstore(add(arg, 0xa0), mload(add(p2y, 0x20)))\\r\\n\\r\\n            mstore(add(arg, 0xc0), mload(p3))\\r\\n            mstore(add(arg, 0xe0), mload(add(p3, 0x20)))\\r\\n\\r\\n            let p4x := mload(p4)\\r\\n            mstore(add(arg, 0x100), mload(p4x))\\r\\n            mstore(add(arg, 0x120), mload(add(p4x, 0x20)))\\r\\n\\r\\n            let p4y := mload(add(p4, 0x20))\\r\\n            mstore(add(arg, 0x140), mload(p4y))\\r\\n            mstore(add(arg, 0x160), mload(add(p4y, 0x20)))\\r\\n\\r\\n            // call(gasLimit, to, value, inputOffset, inputSize, outputOffset, outputSize)\\r\\n            if iszero(staticcall(not(0), 0x08, arg, 0x180, c, 0x20)) {\\r\\n                revert(0, 0)\\r\\n            }\\r\\n            _c := mload(c)\\r\\n        }\\r\\n        return _c != 0;\\r\\n    }\\r\\n\\r\\n    function getP() internal pure returns (uint256) {\\r\\n        return p;\\r\\n    }\\r\\n\\r\\n    function g1() internal pure returns (G1Point memory) {\\r\\n        return G1Point(g1x, g1y);\\r\\n    }\\r\\n\\r\\n    function g2() internal pure returns (G2Point memory) {\\r\\n        return G2Point(gfP2(g2xx, g2xy), gfP2(g2yx, g2yy));\\r\\n    }\\r\\n\\r\\n    /// @dev g2YFromX computes a Y value for a G2 point based on an X value.\\r\\n    ///      This computation is simply evaluating the curve equation for Y on a\\r\\n    ///      given X, and allows a point on the curve to be represented by just\\r\\n    ///      an X value + a sign bit.\\r\\n    function g2YFromX(gfP2 memory _x) internal pure returns (gfP2 memory y) {\\r\\n        (uint256 xx, uint256 xy) = _gfP2CubeAddTwistB(_x.x, _x.y);\\r\\n\\r\\n        // Using formula y = x ^ (p^2 + 15) / 32 from\\r\\n        // https://github.com/ethereum/beacon_chain/blob/master/beacon_chain/utils/bls.py\\r\\n        // (p^2 + 15) / 32 results into a big 512bit value, so breaking it to two uint256 as (a * a + b)\\r\\n        uint256 a = 3869331240733915743250440106392954448556483137451914450067252501901456824595;\\r\\n        uint256 b = 146360017852723390495514512480590656176144969185739259173561346299185050597;\\r\\n\\r\\n        (uint256 xbx, uint256 xby) = _gfP2Pow(xx, xy, b);\\r\\n        (uint256 yax, uint256 yay) = _gfP2Pow(xx, xy, a);\\r\\n        (uint256 ya2x, uint256 ya2y) = _gfP2Pow(yax, yay, a);\\r\\n        (y.x, y.y) = _gfP2Multiply(ya2x, ya2y, xbx, xby);\\r\\n\\r\\n        // Multiply y by hexRoot constant to find correct y.\\r\\n        while (!_g2X2y(xx, xy, y.x, y.y)) {\\r\\n            (y.x, y.y) = _gfP2Multiply(y.x, y.y, hexRootX, hexRootY);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Compress a point on G1 to a single uint256 for serialization.\\r\\n    function g1Compress(G1Point memory point) internal pure returns (bytes32) {\\r\\n        bytes32 m = bytes32(point.x);\\r\\n\\r\\n        bytes1 leadM = m[0] | (parity(point.y) << 7);\\r\\n        // slither-disable-next-line incorrect-shift\\r\\n        uint256 mask = 0xff << (31 * 8);\\r\\n        m = (m & ~bytes32(mask)) | (leadM >> 0);\\r\\n\\r\\n        return m;\\r\\n    }\\r\\n\\r\\n    /// @dev Compress a point on G2 to a pair of uint256 for serialization.\\r\\n    function g2Compress(G2Point memory point)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bytes memory)\\r\\n    {\\r\\n        bytes32 m = bytes32(point.x.x);\\r\\n\\r\\n        bytes1 leadM = m[0] | (parity(point.y.x) << 7);\\r\\n        // slither-disable-next-line incorrect-shift\\r\\n        uint256 mask = 0xff << (31 * 8);\\r\\n        m = (m & ~bytes32(mask)) | (leadM >> 0);\\r\\n\\r\\n        return abi.encodePacked(m, bytes32(point.x.y));\\r\\n    }\\r\\n\\r\\n    /// @dev Unmarshals a point on G1 from bytes in an uncompressed form.\\r\\n    function g1Unmarshal(bytes memory m)\\r\\n        internal\\r\\n        pure\\r\\n        returns (G1Point memory)\\r\\n    {\\r\\n        require(m.length == 64, \\\"Invalid G1 bytes length\\\");\\r\\n\\r\\n        bytes32 x;\\r\\n        bytes32 y;\\r\\n\\r\\n        assembly {\\r\\n            x := mload(add(m, 0x20))\\r\\n            y := mload(add(m, 0x40))\\r\\n        }\\r\\n\\r\\n        return G1Point(uint256(x), uint256(y));\\r\\n    }\\r\\n\\r\\n    /// @dev Marshals a point on G1 to bytes form.\\r\\n    function g1Marshal(G1Point memory point)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bytes memory)\\r\\n    {\\r\\n        bytes memory m = new bytes(64);\\r\\n        bytes32 x = bytes32(point.x);\\r\\n        bytes32 y = bytes32(point.y);\\r\\n\\r\\n        assembly {\\r\\n            mstore(add(m, 32), x)\\r\\n            mstore(add(m, 64), y)\\r\\n        }\\r\\n\\r\\n        return m;\\r\\n    }\\r\\n\\r\\n    /// @dev Unmarshals a point on G2 from bytes in an uncompressed form.\\r\\n    function g2Unmarshal(bytes memory m)\\r\\n        internal\\r\\n        pure\\r\\n        returns (G2Point memory)\\r\\n    {\\r\\n        require(m.length == 128, \\\"Invalid G2 bytes length\\\");\\r\\n\\r\\n        uint256 xx;\\r\\n        uint256 xy;\\r\\n        uint256 yx;\\r\\n        uint256 yy;\\r\\n\\r\\n        assembly {\\r\\n            xx := mload(add(m, 0x20))\\r\\n            xy := mload(add(m, 0x40))\\r\\n            yx := mload(add(m, 0x60))\\r\\n            yy := mload(add(m, 0x80))\\r\\n        }\\r\\n\\r\\n        return G2Point(gfP2(xx, xy), gfP2(yx, yy));\\r\\n    }\\r\\n\\r\\n    /// @dev Decompress a point on G2 from a pair of uint256.\\r\\n    function g2Decompress(bytes memory m)\\r\\n        internal\\r\\n        pure\\r\\n        returns (G2Point memory)\\r\\n    {\\r\\n        require(m.length == 64, \\\"Invalid G2 compressed bytes length\\\");\\r\\n\\r\\n        bytes32 x1;\\r\\n        bytes32 x2;\\r\\n        uint256 temp;\\r\\n\\r\\n        // Extract two bytes32 from bytes array\\r\\n        assembly {\\r\\n            temp := add(m, 32)\\r\\n            x1 := mload(temp)\\r\\n            temp := add(m, 64)\\r\\n            x2 := mload(temp)\\r\\n        }\\r\\n\\r\\n        bytes32 mX = bytes32(0);\\r\\n        bytes1 leadX = x1[0] & 0x7f;\\r\\n        // slither-disable-next-line incorrect-shift\\r\\n        uint256 mask = 0xff << (31 * 8);\\r\\n        mX = (x1 & ~bytes32(mask)) | (leadX >> 0);\\r\\n\\r\\n        gfP2 memory x = gfP2(uint256(mX), uint256(x2));\\r\\n        gfP2 memory y = g2YFromX(x);\\r\\n\\r\\n        if (parity(y.x) != (m[0] & 0x80) >> 7) {\\r\\n            y.x = p - y.x;\\r\\n            y.y = p - y.y;\\r\\n        }\\r\\n\\r\\n        return G2Point(x, y);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the sum of two gfP2 field elements.\\r\\n    function gfP2Add(gfP2 memory a, gfP2 memory b)\\r\\n        internal\\r\\n        pure\\r\\n        returns (gfP2 memory)\\r\\n    {\\r\\n        return gfP2(addmod(a.x, b.x, p), addmod(a.y, b.y, p));\\r\\n    }\\r\\n\\r\\n    /// @dev Returns multiplication of two gfP2 field elements.\\r\\n    function gfP2Multiply(gfP2 memory a, gfP2 memory b)\\r\\n        internal\\r\\n        pure\\r\\n        returns (gfP2 memory)\\r\\n    {\\r\\n        return\\r\\n            gfP2(\\r\\n                addmod(mulmod(a.x, b.y, p), mulmod(b.x, a.y, p), p),\\r\\n                addmod(mulmod(a.y, b.y, p), p - mulmod(a.x, b.x, p), p)\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /// @dev Returns gfP2 element to the power of the provided exponent.\\r\\n    function gfP2Pow(gfP2 memory _a, uint256 _exp)\\r\\n        internal\\r\\n        pure\\r\\n        returns (gfP2 memory result)\\r\\n    {\\r\\n        (uint256 x, uint256 y) = _gfP2Pow(_a.x, _a.y, _exp);\\r\\n        return gfP2(x, y);\\r\\n    }\\r\\n\\r\\n    function gfP2Square(gfP2 memory a) internal pure returns (gfP2 memory) {\\r\\n        return gfP2Multiply(a, a);\\r\\n    }\\r\\n\\r\\n    function gfP2Cube(gfP2 memory a) internal pure returns (gfP2 memory) {\\r\\n        return gfP2Multiply(a, gfP2Square(a));\\r\\n    }\\r\\n\\r\\n    function gfP2CubeAddTwistB(gfP2 memory a)\\r\\n        internal\\r\\n        pure\\r\\n        returns (gfP2 memory)\\r\\n    {\\r\\n        (uint256 x, uint256 y) = _gfP2CubeAddTwistB(a.x, a.y);\\r\\n        return gfP2(x, y);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns true if G2 point's y^2 equals x.\\r\\n    function g2X2y(gfP2 memory x, gfP2 memory y) internal pure returns (bool) {\\r\\n        gfP2 memory y2;\\r\\n        y2 = gfP2Square(y);\\r\\n\\r\\n        return (y2.x == x.x && y2.y == x.y);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns true if G2 point is on the curve.\\r\\n    function isG2PointOnCurve(G2Point memory point)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bool)\\r\\n    {\\r\\n        (uint256 y2x, uint256 y2y) = _gfP2Square(point.y.x, point.y.y);\\r\\n        (uint256 x3x, uint256 x3y) = _gfP2CubeAddTwistB(point.x.x, point.x.y);\\r\\n\\r\\n        return (y2x == x3x && y2y == x3y);\\r\\n    }\\r\\n\\r\\n    function twistB() private pure returns (gfP2 memory) {\\r\\n        return gfP2(twistBx, twistBy);\\r\\n    }\\r\\n\\r\\n    function hexRoot() private pure returns (gfP2 memory) {\\r\\n        return gfP2(hexRootX, hexRootY);\\r\\n    }\\r\\n\\r\\n    /// @dev Calculates whether the provided number is even or odd.\\r\\n    /// @return 0x01 if y is an even number and 0x00 if it's odd.\\r\\n    function parity(uint256 value) private pure returns (bytes1) {\\r\\n        return bytes32(value)[31] & 0x01;\\r\\n    }\\r\\n\\r\\n    function _gfP2Add(\\r\\n        uint256 ax,\\r\\n        uint256 ay,\\r\\n        uint256 bx,\\r\\n        uint256 by\\r\\n    ) private pure returns (uint256 x, uint256 y) {\\r\\n        x = addmod(ax, bx, p);\\r\\n        y = addmod(ay, by, p);\\r\\n    }\\r\\n\\r\\n    function _gfP2Multiply(\\r\\n        uint256 ax,\\r\\n        uint256 ay,\\r\\n        uint256 bx,\\r\\n        uint256 by\\r\\n    ) private pure returns (uint256 x, uint256 y) {\\r\\n        x = addmod(mulmod(ax, by, p), mulmod(bx, ay, p), p);\\r\\n        y = addmod(mulmod(ay, by, p), p - mulmod(ax, bx, p), p);\\r\\n    }\\r\\n\\r\\n    function _gfP2CubeAddTwistB(uint256 ax, uint256 ay)\\r\\n        private\\r\\n        pure\\r\\n        returns (uint256 x, uint256 y)\\r\\n    {\\r\\n        (uint256 a3x, uint256 a3y) = _gfP2Cube(ax, ay);\\r\\n        return _gfP2Add(a3x, a3y, twistBx, twistBy);\\r\\n    }\\r\\n\\r\\n    function _gfP2Pow(\\r\\n        uint256 _ax,\\r\\n        uint256 _ay,\\r\\n        uint256 _exp\\r\\n    ) private pure returns (uint256 x, uint256 y) {\\r\\n        uint256 exp = _exp;\\r\\n        x = 0;\\r\\n        y = 1;\\r\\n        uint256 ax = _ax;\\r\\n        uint256 ay = _ay;\\r\\n\\r\\n        // Reduce exp dividing by 2 gradually to 0 while computing final\\r\\n        // result only when exp is an odd number.\\r\\n        while (exp > 0) {\\r\\n            if (parity(exp) == 0x01) {\\r\\n                (x, y) = _gfP2Multiply(x, y, ax, ay);\\r\\n            }\\r\\n\\r\\n            unchecked {\\r\\n                exp = exp / 2;\\r\\n            }\\r\\n            (ax, ay) = _gfP2Multiply(ax, ay, ax, ay);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _gfP2Square(uint256 _ax, uint256 _ay)\\r\\n        private\\r\\n        pure\\r\\n        returns (uint256 x, uint256 y)\\r\\n    {\\r\\n        return _gfP2Multiply(_ax, _ay, _ax, _ay);\\r\\n    }\\r\\n\\r\\n    function _gfP2Cube(uint256 _ax, uint256 _ay)\\r\\n        private\\r\\n        pure\\r\\n        returns (uint256 x, uint256 y)\\r\\n    {\\r\\n        (uint256 _bx, uint256 _by) = _gfP2Square(_ax, _ay);\\r\\n        return _gfP2Multiply(_ax, _ay, _bx, _by);\\r\\n    }\\r\\n\\r\\n    function _g2X2y(\\r\\n        uint256 xx,\\r\\n        uint256 xy,\\r\\n        uint256 yx,\\r\\n        uint256 yy\\r\\n    ) private pure returns (bool) {\\r\\n        (uint256 y2x, uint256 y2y) = _gfP2Square(yx, yy);\\r\\n\\r\\n        return (y2x == xx && y2y == xy);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x998e0fe648264ce8340845e645e7d13a8e75993f496907aba2030e55c54f118c\",\"license\":\"GPL-3.0-only\"},\"contracts/libraries/BLS.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\r\\n//\\r\\n// \\u2593\\u2593\\u258c \\u2593\\u2593 \\u2590\\u2593\\u2593 \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u258c\\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2584\\r\\n// \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u258c\\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\r\\n//   \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593    \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2580    \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593    \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593   \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593     \\u2593\\u2593\\u2593\\u2593\\u2593   \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u258c   \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\r\\n//   \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2584\\u2584\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2580      \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2584\\u2584\\u2584\\u2584         \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2584\\u2584\\u2584\\u2584         \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u258c   \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\r\\n//   \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2580        \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593         \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593         \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\r\\n//   \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2580\\u2580\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2584       \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2580\\u2580\\u2580\\u2580         \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2580\\u2580\\u2580\\u2580         \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2580\\r\\n//   \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593   \\u2580\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2584     \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593     \\u2593\\u2593\\u2593\\u2593\\u2593   \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593     \\u2593\\u2593\\u2593\\u2593\\u2593   \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u258c\\r\\n// \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593  \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\r\\n// \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593  \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\r\\n//\\r\\n//\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./AltBn128.sol\\\";\\r\\n\\r\\n/// @title BLS signatures verification\\r\\n/// @dev Library for verification of 2-pairing-check BLS signatures, including\\r\\n///      basic, aggregated, or reconstructed threshold BLS signatures, generated\\r\\n///      using the AltBn128 curve.\\r\\nlibrary BLS {\\r\\n    /// @dev Creates a signature over message using the provided secret key.\\r\\n    function sign(bytes memory message, uint256 secretKey)\\r\\n        external\\r\\n        view\\r\\n        returns (bytes memory)\\r\\n    {\\r\\n        AltBn128.G1Point memory p_1 = AltBn128.g1HashToPoint(message);\\r\\n        AltBn128.G1Point memory p_2 = AltBn128.scalarMultiply(p_1, secretKey);\\r\\n\\r\\n        return AltBn128.g1Marshal(p_2);\\r\\n    }\\r\\n\\r\\n    /// @dev Wraps the functionality of BLS.verify, but hashes a message to\\r\\n    ///      a point on G1 and marshal to bytes first to allow raw bytes\\r\\n    ///      verification.\\r\\n    function verifyBytes(\\r\\n        bytes memory publicKey,\\r\\n        bytes memory message,\\r\\n        bytes memory signature\\r\\n    ) external view returns (bool) {\\r\\n        AltBn128.G1Point memory point = AltBn128.g1HashToPoint(message);\\r\\n        bytes memory messageAsPoint = AltBn128.g1Marshal(point);\\r\\n\\r\\n        return verify(publicKey, messageAsPoint, signature);\\r\\n    }\\r\\n\\r\\n    /// @dev Verify performs the pairing operation to check if the signature\\r\\n    ///      is correct for the provided message and the corresponding public\\r\\n    ///      key. Public key must be a valid point on G2 curve in an\\r\\n    ///      uncompressed format. Message must be a valid point on G1 curve in\\r\\n    ///      an uncompressed format. Signature must be a valid point on G1\\r\\n    ///      curve in an uncompressed format.\\r\\n    function verify(\\r\\n        bytes memory publicKey,\\r\\n        bytes memory message,\\r\\n        bytes memory signature\\r\\n    ) public view returns (bool) {\\r\\n        AltBn128.G1Point memory _signature = AltBn128.g1Unmarshal(signature);\\r\\n\\r\\n        return\\r\\n            _verify(\\r\\n                AltBn128.g2Unmarshal(publicKey),\\r\\n                AltBn128.g1Unmarshal(message),\\r\\n                _signature\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function _verify(\\r\\n        AltBn128.G2Point memory publicKey,\\r\\n        AltBn128.G1Point memory message,\\r\\n        AltBn128.G1Point memory signature\\r\\n    ) public view returns (bool) {\\r\\n        return\\r\\n            AltBn128.pairing(\\r\\n                AltBn128.G1Point(signature.x, AltBn128.getP() - signature.y),\\r\\n                AltBn128.g2(),\\r\\n                message,\\r\\n                publicKey\\r\\n            );\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x904bba47b6faa62d70f279211216f5bfa2f095a0c304330647a849a0bc0ad045\",\"license\":\"GPL-3.0-only\"},\"contracts/libraries/ModUtils.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\r\\n//\\r\\n// \\u2593\\u2593\\u258c \\u2593\\u2593 \\u2590\\u2593\\u2593 \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u258c\\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2584\\r\\n// \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u258c\\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\r\\n//   \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593    \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2580    \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593    \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593   \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593     \\u2593\\u2593\\u2593\\u2593\\u2593   \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u258c   \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\r\\n//   \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2584\\u2584\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2580      \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2584\\u2584\\u2584\\u2584         \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2584\\u2584\\u2584\\u2584         \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u258c   \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\r\\n//   \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2580        \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593         \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593         \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\r\\n//   \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2580\\u2580\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2584       \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2580\\u2580\\u2580\\u2580         \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2580\\u2580\\u2580\\u2580         \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2580\\r\\n//   \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593   \\u2580\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2584     \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593     \\u2593\\u2593\\u2593\\u2593\\u2593   \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593     \\u2593\\u2593\\u2593\\u2593\\u2593   \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u258c\\r\\n// \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593  \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\r\\n// \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2590\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593 \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593  \\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\r\\n//\\r\\n//\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nlibrary ModUtils {\\r\\n    /// @dev Wraps the modular exponent pre-compile introduced in Byzantium.\\r\\n    ///      Returns base^exponent mod p.\\r\\n    function modExp(\\r\\n        uint256 base,\\r\\n        uint256 exponent,\\r\\n        uint256 p\\r\\n    ) internal view returns (uint256 o) {\\r\\n        assembly {\\r\\n            // Args for the precompile: [<length_of_BASE> <length_of_EXPONENT>\\r\\n            // <length_of_MODULUS> <BASE> <EXPONENT> <MODULUS>]\\r\\n            let output := mload(0x40)\\r\\n            let args := add(output, 0x20)\\r\\n            mstore(args, 0x20)\\r\\n            mstore(add(args, 0x20), 0x20)\\r\\n            mstore(add(args, 0x40), 0x20)\\r\\n            mstore(add(args, 0x60), base)\\r\\n            mstore(add(args, 0x80), exponent)\\r\\n            mstore(add(args, 0xa0), p)\\r\\n\\r\\n            // 0x05 is the modular exponent contract address\\r\\n            if iszero(staticcall(not(0), 0x05, args, 0xc0, output, 0x20)) {\\r\\n                revert(0, 0)\\r\\n            }\\r\\n            o := mload(output)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Calculates and returns the square root of a mod p if such a square\\r\\n    ///      root exists. The modulus p must be an odd prime. If a square root\\r\\n    ///      does not exist, function returns 0.\\r\\n    function modSqrt(uint256 a, uint256 p) internal view returns (uint256) {\\r\\n        unchecked {\\r\\n            if (legendre(a, p) != 1) {\\r\\n                return 0;\\r\\n            }\\r\\n\\r\\n            if (a == 0) {\\r\\n                return 0;\\r\\n            }\\r\\n\\r\\n            if (p % 4 == 3) {\\r\\n                return modExp(a, (p + 1) / 4, p);\\r\\n            }\\r\\n\\r\\n            uint256 s = p - 1;\\r\\n            uint256 e = 0;\\r\\n\\r\\n            while (s % 2 == 0) {\\r\\n                s = s / 2;\\r\\n                e = e + 1;\\r\\n            }\\r\\n\\r\\n            // Note the smaller int- finding n with Legendre symbol or -1\\r\\n            // should be quick\\r\\n            uint256 n = 2;\\r\\n            while (legendre(n, p) != -1) {\\r\\n                n = n + 1;\\r\\n            }\\r\\n\\r\\n            uint256 x = modExp(a, (s + 1) / 2, p);\\r\\n            uint256 b = modExp(a, s, p);\\r\\n            uint256 g = modExp(n, s, p);\\r\\n            uint256 r = e;\\r\\n            uint256 gs = 0;\\r\\n            uint256 m = 0;\\r\\n            uint256 t = b;\\r\\n\\r\\n            while (true) {\\r\\n                t = b;\\r\\n                m = 0;\\r\\n\\r\\n                for (m = 0; m < r; m++) {\\r\\n                    if (t == 1) {\\r\\n                        break;\\r\\n                    }\\r\\n                    t = modExp(t, 2, p);\\r\\n                }\\r\\n\\r\\n                if (m == 0) {\\r\\n                    return x;\\r\\n                }\\r\\n\\r\\n                gs = modExp(g, uint256(2)**(r - m - 1), p);\\r\\n                g = (gs * gs) % p;\\r\\n                x = (x * gs) % p;\\r\\n                b = (b * g) % p;\\r\\n                r = m;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Calculates the Legendre symbol of the given a mod p.\\r\\n    /// @return Returns 1 if a is a quadratic residue mod p, -1 if it is\\r\\n    ///         a non-quadratic residue, and 0 if a is 0.\\r\\n    function legendre(uint256 a, uint256 p) internal view returns (int256) {\\r\\n        unchecked {\\r\\n            uint256 raised = modExp(a, (p - 1) / uint256(2), p);\\r\\n\\r\\n            if (raised == 0 || raised == 1) {\\r\\n                return int256(raised);\\r\\n            } else if (raised == p - 1) {\\r\\n                return -1;\\r\\n            }\\r\\n\\r\\n            require(false, \\\"Failed to calculate legendre.\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x2b6514532fb6236b79b3e87b76d1e7b8f9e09cdc248d743f115d56f0745fa13f\",\"license\":\"GPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x610be261003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100565760003560e01c8063afef5d331461005b578063b6087a0f14610084578063de8f50a1146100a7578063e71b17c4146100ba575b600080fd5b61006e61006936600461093c565b6100cd565b60405161007b91906109a5565b60405180910390f35b610097610092366004610a08565b6100fe565b604051901515815260200161007b565b6100976100b5366004610a7b565b610167565b6100976100c8366004610a7b565b610199565b606060006100da846101c9565b905060006100e8828561028c565b90506100f3816102d3565b925050505b92915050565b600061015f60405180604001604052808460000151815260200184602001516101447f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4790565b61014e9190610b19565b905261015861030d565b85876103cd565b949350505050565b60008061017383610474565b9050610190610181866104fd565b61018a86610474565b836100fe565b95945050505050565b6000806101a5846101c9565b905060006101b2826102d3565b90506101bf868286610167565b9695505050505050565b604080518082019091526000808252602082015260006002836040516101ef9190610b2c565b602060405180830381855afa15801561020c573d6000803e3d6000fd5b5050506040513d601f19601f8201168201806040525081019061022f9190610b48565b90507f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47810660005b6102608261059e565b90508015610281576040805180820190915291825260208201529392505050565b600182019150610257565b604080518082019091526000808252602082015260405183518152602084015160208201528260408201526040826060836007600019fa6102cc57600080fd5b5092915050565b6040805181815260608181018352916000919060208201818036833750508451602095860151958301525060408101939093525090919050565b61031561082c565b50604080516080810182527f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c28183019081527f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed6060830152815281518083019092527f090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b82527f12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa60208381019190915281019190915290565b6000806040516020810187518152602088015160208201528651805160408301526020810151606083015250602087015180516080830152602081015160a083015250855160c0820152602086015160e08201528451805161010083015260208101516101208301525060208501518051610140830152602081015161016083015250602082610180836008600019fa61046657600080fd5b505115159695505050505050565b604080518082019091526000808252602082015281516040146104de5760405162461bcd60e51b815260206004820152601760248201527f496e76616c6964204731206279746573206c656e67746800000000000000000060448201526064015b60405180910390fd5b5060208181015160409283015183518085019094529083529082015290565b61050561082c565b81516080146105565760405162461bcd60e51b815260206004820152601760248201527f496e76616c6964204732206279746573206c656e67746800000000000000000060448201526064016104d5565b50602081810151604080840151606080860151608096870151845197880185528785019586529187019290925292855281518083019092528152808301919091529082015290565b60006100f87f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47806105d1856003836105ec565b6105dc906003610b77565b6105e69190610b8a565b90610637565b60006040516020810160208152602080820152602060408201528560608201528460808201528360a082015260208260c0836005600019fa61062d57600080fd5b5051949350505050565b6000610643838361079f565b600114610652575060006100f8565b82600003610662575060006100f8565b600482066003036106855761067e8360046001850104846105ec565b90506100f8565b600019820160005b600282066000036106a65760028204915060010161068d565b60025b6106b3818661079f565b600019146106c3576001016106a9565b60006106d68760026001870104886105ec565b905060006106e58886896105ec565b905060006106f484878a6105ec565b905084600080845b5060009050845b8382101561072c576001811461072c5761071f8160028e6105ec565b6001909201919050610703565b8160000361074657869a50505050505050505050506100f8565b6107598560018487030360020a8e6105ec565b92508b8384028161076c5761076c610b61565b0694508b8388028161078057610780610b61565b0696508b8587028161079457610794610b61565b0695508193506106fc565b6000806107b4846002600019860104856105ec565b90508015806107c35750806001145b156107cf5790506100f8565b6001830381036107e4576000199150506100f8565b60405162461bcd60e51b815260206004820152601d60248201527f4661696c656420746f2063616c63756c617465206c6567656e6472652e00000060448201526064016104d5565b6040805160808101825260009181018281526060820192909252908190815260200161086b604051806040016040528060008152602001600081525090565b905290565b634e487b7160e01b600052604160045260246000fd5b6040805190810167ffffffffffffffff811182821017156108a9576108a9610870565b60405290565b600082601f8301126108c057600080fd5b813567ffffffffffffffff808211156108db576108db610870565b604051601f8301601f19908116603f0116810190828211818310171561090357610903610870565b8160405283815286602085880101111561091c57600080fd5b836020870160208301376000602085830101528094505050505092915050565b6000806040838503121561094f57600080fd5b823567ffffffffffffffff81111561096657600080fd5b610972858286016108af565b95602094909401359450505050565b60005b8381101561099c578181015183820152602001610984565b50506000910152565b60208152600082518060208401526109c4816040850160208701610981565b601f01601f19169190910160400192915050565b6000604082840312156109ea57600080fd5b6109f2610886565b9050813581526020820135602082015292915050565b6000806000838503610100811215610a1f57600080fd5b6080811215610a2d57600080fd5b50610a36610886565b610a4086866109d8565b8152610a4f86604087016109d8565b60208201529250610a6385608086016109d8565b9150610a728560c086016109d8565b90509250925092565b600080600060608486031215610a9057600080fd5b833567ffffffffffffffff80821115610aa857600080fd5b610ab4878388016108af565b94506020860135915080821115610aca57600080fd5b610ad6878388016108af565b93506040860135915080821115610aec57600080fd5b50610af9868287016108af565b9150509250925092565b634e487b7160e01b600052601160045260246000fd5b818103818111156100f8576100f8610b03565b60008251610b3e818460208701610981565b9190910192915050565b600060208284031215610b5a57600080fd5b5051919050565b634e487b7160e01b600052601260045260246000fd5b808201808211156100f8576100f8610b03565b600082610ba757634e487b7160e01b600052601260045260246000fd5b50069056fea264697066735822122020350d0a7747824640f566c977a3ff70aec6e19dbc40bb13bbf797b54001477264736f6c63430008110033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100565760003560e01c8063afef5d331461005b578063b6087a0f14610084578063de8f50a1146100a7578063e71b17c4146100ba575b600080fd5b61006e61006936600461093c565b6100cd565b60405161007b91906109a5565b60405180910390f35b610097610092366004610a08565b6100fe565b604051901515815260200161007b565b6100976100b5366004610a7b565b610167565b6100976100c8366004610a7b565b610199565b606060006100da846101c9565b905060006100e8828561028c565b90506100f3816102d3565b925050505b92915050565b600061015f60405180604001604052808460000151815260200184602001516101447f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4790565b61014e9190610b19565b905261015861030d565b85876103cd565b949350505050565b60008061017383610474565b9050610190610181866104fd565b61018a86610474565b836100fe565b95945050505050565b6000806101a5846101c9565b905060006101b2826102d3565b90506101bf868286610167565b9695505050505050565b604080518082019091526000808252602082015260006002836040516101ef9190610b2c565b602060405180830381855afa15801561020c573d6000803e3d6000fd5b5050506040513d601f19601f8201168201806040525081019061022f9190610b48565b90507f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47810660005b6102608261059e565b90508015610281576040805180820190915291825260208201529392505050565b600182019150610257565b604080518082019091526000808252602082015260405183518152602084015160208201528260408201526040826060836007600019fa6102cc57600080fd5b5092915050565b6040805181815260608181018352916000919060208201818036833750508451602095860151958301525060408101939093525090919050565b61031561082c565b50604080516080810182527f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c28183019081527f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed6060830152815281518083019092527f090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b82527f12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa60208381019190915281019190915290565b6000806040516020810187518152602088015160208201528651805160408301526020810151606083015250602087015180516080830152602081015160a083015250855160c0820152602086015160e08201528451805161010083015260208101516101208301525060208501518051610140830152602081015161016083015250602082610180836008600019fa61046657600080fd5b505115159695505050505050565b604080518082019091526000808252602082015281516040146104de5760405162461bcd60e51b815260206004820152601760248201527f496e76616c6964204731206279746573206c656e67746800000000000000000060448201526064015b60405180910390fd5b5060208181015160409283015183518085019094529083529082015290565b61050561082c565b81516080146105565760405162461bcd60e51b815260206004820152601760248201527f496e76616c6964204732206279746573206c656e67746800000000000000000060448201526064016104d5565b50602081810151604080840151606080860151608096870151845197880185528785019586529187019290925292855281518083019092528152808301919091529082015290565b60006100f87f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47806105d1856003836105ec565b6105dc906003610b77565b6105e69190610b8a565b90610637565b60006040516020810160208152602080820152602060408201528560608201528460808201528360a082015260208260c0836005600019fa61062d57600080fd5b5051949350505050565b6000610643838361079f565b600114610652575060006100f8565b82600003610662575060006100f8565b600482066003036106855761067e8360046001850104846105ec565b90506100f8565b600019820160005b600282066000036106a65760028204915060010161068d565b60025b6106b3818661079f565b600019146106c3576001016106a9565b60006106d68760026001870104886105ec565b905060006106e58886896105ec565b905060006106f484878a6105ec565b905084600080845b5060009050845b8382101561072c576001811461072c5761071f8160028e6105ec565b6001909201919050610703565b8160000361074657869a50505050505050505050506100f8565b6107598560018487030360020a8e6105ec565b92508b8384028161076c5761076c610b61565b0694508b8388028161078057610780610b61565b0696508b8587028161079457610794610b61565b0695508193506106fc565b6000806107b4846002600019860104856105ec565b90508015806107c35750806001145b156107cf5790506100f8565b6001830381036107e4576000199150506100f8565b60405162461bcd60e51b815260206004820152601d60248201527f4661696c656420746f2063616c63756c617465206c6567656e6472652e00000060448201526064016104d5565b6040805160808101825260009181018281526060820192909252908190815260200161086b604051806040016040528060008152602001600081525090565b905290565b634e487b7160e01b600052604160045260246000fd5b6040805190810167ffffffffffffffff811182821017156108a9576108a9610870565b60405290565b600082601f8301126108c057600080fd5b813567ffffffffffffffff808211156108db576108db610870565b604051601f8301601f19908116603f0116810190828211818310171561090357610903610870565b8160405283815286602085880101111561091c57600080fd5b836020870160208301376000602085830101528094505050505092915050565b6000806040838503121561094f57600080fd5b823567ffffffffffffffff81111561096657600080fd5b610972858286016108af565b95602094909401359450505050565b60005b8381101561099c578181015183820152602001610984565b50506000910152565b60208152600082518060208401526109c4816040850160208701610981565b601f01601f19169190910160400192915050565b6000604082840312156109ea57600080fd5b6109f2610886565b9050813581526020820135602082015292915050565b6000806000838503610100811215610a1f57600080fd5b6080811215610a2d57600080fd5b50610a36610886565b610a4086866109d8565b8152610a4f86604087016109d8565b60208201529250610a6385608086016109d8565b9150610a728560c086016109d8565b90509250925092565b600080600060608486031215610a9057600080fd5b833567ffffffffffffffff80821115610aa857600080fd5b610ab4878388016108af565b94506020860135915080821115610aca57600080fd5b610ad6878388016108af565b93506040860135915080821115610aec57600080fd5b50610af9868287016108af565b9150509250925092565b634e487b7160e01b600052601160045260246000fd5b818103818111156100f8576100f8610b03565b60008251610b3e818460208701610981565b9190910192915050565b600060208284031215610b5a57600080fd5b5051919050565b634e487b7160e01b600052601260045260246000fd5b808201808211156100f8576100f8610b03565b600082610ba757634e487b7160e01b600052601260045260246000fd5b50069056fea264697066735822122020350d0a7747824640f566c977a3ff70aec6e19dbc40bb13bbf797b54001477264736f6c63430008110033",
  "devdoc": {
    "details": "Library for verification of 2-pairing-check BLS signatures, including      basic, aggregated, or reconstructed threshold BLS signatures, generated      using the AltBn128 curve.",
    "kind": "dev",
    "methods": {
      "sign(bytes,uint256)": {
        "details": "Creates a signature over message using the provided secret key."
      },
      "verify(bytes,bytes,bytes)": {
        "details": "Verify performs the pairing operation to check if the signature      is correct for the provided message and the corresponding public      key. Public key must be a valid point on G2 curve in an      uncompressed format. Message must be a valid point on G1 curve in      an uncompressed format. Signature must be a valid point on G1      curve in an uncompressed format."
      },
      "verifyBytes(bytes,bytes,bytes)": {
        "details": "Wraps the functionality of BLS.verify, but hashes a message to      a point on G1 and marshal to bytes first to allow raw bytes      verification."
      }
    },
    "title": "BLS signatures verification",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}